{"version":3,"file":"static/module-azure.d44ddf30.js","mappings":"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","sources":["webpack://app/../../node_modules/@azure/logger/dist/browser/index.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/logging.js","webpack://app/../../node_modules/@azure/identity/dist/browser/errors.js","webpack://app/../../node_modules/@azure/identity/dist/browser/constants.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/tracingContext.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/state.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/instrumenter.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/tracingClient.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/tracing.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/chainedTokenCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/defaultAzureCredential.js","webpack://app/../../node_modules/@azure/abort-controller/dist/browser/AbortError.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/createAbortablePromise.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/delay.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/error.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/index.js","webpack://app/../../node_modules/@azure/identity/dist/browser/msal/utils.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/pipeline.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/log.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/logPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/redirectPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgentPlatform.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/constants.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgent.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/userAgentPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/file.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/multipartPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/decompressResponsePolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/defaultRetryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/formDataPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/proxyPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/setClientRequestIdPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/agentPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/tlsPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/restError.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/tracingPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/wrapAbortSignal.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/wrapAbortSignalLikePolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/createPipelineFromOptions.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/defaultHttpClient.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/httpHeaders.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/pipelineRequest.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/exponentialRetryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/systemErrorRetryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/throttlingRetryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/retryPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/tokenCycler.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/bearerTokenAuthenticationPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/auxiliaryAuthenticationHeaderPolicy.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/tenantIdUtils.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/serializer.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/interfaces.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/state.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/operationHelpers.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/deserializationPolicy.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/interfaceHelpers.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/serializationPolicy.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/pipeline.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/utils.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/httpClientCache.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/urlHelpers.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/log.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/serviceClient.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/authorizeRequestOnClaimChallenge.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/authorizeRequestOnTenantChallenge.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/identityTokenEndpoint.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/managedIdentityCredential/utils.js","webpack://app/../../node_modules/@azure/identity/dist/browser/client/identityClient.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/clientSecretCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/environmentCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/clientCertificateCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/clientAssertionCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azureCliCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azureDeveloperCliCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/scopeUtils.js","webpack://app/../../node_modules/@azure/identity/dist/browser/msal/browserFlows/msalBrowserCommon.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/interactiveBrowserCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/managedIdentityCredential/index.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/deviceCodeCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azurePipelinesCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/authorizationCodeCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azurePowerShellCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/usernamePasswordCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/visualStudioCodeCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/onBehalfOfCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/workloadIdentityCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/tokenProvider.js","webpack://app/../../node_modules/@azure/identity/dist/browser/index.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createLoggerContext } from \"@typespec/ts-http-runtime/internal/logger\";\nconst context = createLoggerContext({\n    logLevelEnvVarName: \"AZURE_LOG_LEVEL\",\n    namespace: \"azure\",\n});\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\nexport const AzureLogger = context.logger;\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport function setLogLevel(level) {\n    context.setLogLevel(level);\n}\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n    return context.getLogLevel();\n}\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace) {\n    return context.createClientLogger(namespace);\n}\n//# sourceMappingURL=index.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\n/**\n * The AzureLogger used for all clients within the identity package\n */\nexport const logger = createClientLogger(\"identity\");\n/**\n * Separates a list of environment variable names into a plain object with two arrays: an array of missing environment variables and another array with assigned environment variables.\n * @param supportedEnvVars - List of environment variable names\n */\nexport function processEnvVars(supportedEnvVars) {\n    return supportedEnvVars.reduce((acc, envVariable) => {\n        if (process.env[envVariable]) {\n            acc.assigned.push(envVariable);\n        }\n        else {\n            acc.missing.push(envVariable);\n        }\n        return acc;\n    }, { missing: [], assigned: [] });\n}\n/**\n * Based on a given list of environment variable names,\n * logs the environment variables currently assigned during the usage of a credential that goes by the given name.\n * @param credentialName - Name of the credential in use\n * @param supportedEnvVars - List of environment variables supported by that credential\n */\nexport function logEnvVars(credentialName, supportedEnvVars) {\n    const { assigned } = processEnvVars(supportedEnvVars);\n    logger.info(`${credentialName} => Found the following environment variables: ${assigned.join(\", \")}`);\n}\n/**\n * Formatting the success event on the credentials\n */\nexport function formatSuccess(scope) {\n    return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(\", \") : scope}.`;\n}\n/**\n * Formatting the success event on the credentials\n */\nexport function formatError(scope, error) {\n    let message = \"ERROR.\";\n    if (scope === null || scope === void 0 ? void 0 : scope.length) {\n        message += ` Scopes: ${Array.isArray(scope) ? scope.join(\", \") : scope}.`;\n    }\n    return `${message} Error message: ${typeof error === \"string\" ? error : error.message}.`;\n}\n/**\n * Generates a CredentialLoggerInstance.\n *\n * It logs with the format:\n *\n *   `[title] => [message]`\n *\n */\nexport function credentialLoggerInstance(title, parent, log = logger) {\n    const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;\n    function info(message) {\n        log.info(`${fullTitle} =>`, message);\n    }\n    function warning(message) {\n        log.warning(`${fullTitle} =>`, message);\n    }\n    function verbose(message) {\n        log.verbose(`${fullTitle} =>`, message);\n    }\n    function error(message) {\n        log.error(`${fullTitle} =>`, message);\n    }\n    return {\n        title,\n        fullTitle,\n        info,\n        warning,\n        verbose,\n        error,\n    };\n}\n/**\n * Generates a CredentialLogger, which is a logger declared at the credential's constructor, and used at any point in the credential.\n * It has all the properties of a CredentialLoggerInstance, plus other logger instances, one per method.\n *\n * It logs with the format:\n *\n *   `[title] => [message]`\n *   `[title] => getToken() => [message]`\n *\n */\nexport function credentialLogger(title, log = logger) {\n    const credLogger = credentialLoggerInstance(title, undefined, log);\n    return Object.assign(Object.assign({}, credLogger), { parent: log, getToken: credentialLoggerInstance(\"=> getToken()\", credLogger, log) });\n}\n//# sourceMappingURL=logging.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nfunction isErrorResponse(errorResponse) {\n    return (errorResponse &&\n        typeof errorResponse.error === \"string\" &&\n        typeof errorResponse.error_description === \"string\");\n}\n/**\n * The Error.name value of an CredentialUnavailable\n */\nexport const CredentialUnavailableErrorName = \"CredentialUnavailableError\";\n/**\n * This signifies that the credential that was tried in a chained credential\n * was not available to be used as the credential. Rather than treating this as\n * an error that should halt the chain, it's caught and the chain continues\n */\nexport class CredentialUnavailableError extends Error {\n    constructor(message, options) {\n        // @ts-expect-error - TypeScript does not recognize this until we use ES2022 as the target; however, all our major runtimes do support the `cause` property\n        super(message, options);\n        this.name = CredentialUnavailableErrorName;\n    }\n}\n/**\n * The Error.name value of an AuthenticationError\n */\nexport const AuthenticationErrorName = \"AuthenticationError\";\n/**\n * Provides details about a failure to authenticate with Azure Active\n * Directory.  The `errorResponse` field contains more details about\n * the specific failure.\n */\nexport class AuthenticationError extends Error {\n    constructor(statusCode, errorBody, options) {\n        let errorResponse = {\n            error: \"unknown\",\n            errorDescription: \"An unknown error occurred and no additional details are available.\",\n        };\n        if (isErrorResponse(errorBody)) {\n            errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);\n        }\n        else if (typeof errorBody === \"string\") {\n            try {\n                // Most error responses will contain JSON-formatted error details\n                // in the response body\n                const oauthErrorResponse = JSON.parse(errorBody);\n                errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);\n            }\n            catch (e) {\n                if (statusCode === 400) {\n                    errorResponse = {\n                        error: \"invalid_request\",\n                        errorDescription: `The service indicated that the request was invalid.\\n\\n${errorBody}`,\n                    };\n                }\n                else {\n                    errorResponse = {\n                        error: \"unknown_error\",\n                        errorDescription: `An unknown error has occurred. Response body:\\n\\n${errorBody}`,\n                    };\n                }\n            }\n        }\n        else {\n            errorResponse = {\n                error: \"unknown_error\",\n                errorDescription: \"An unknown error occurred and no additional details are available.\",\n            };\n        }\n        super(`${errorResponse.error} Status code: ${statusCode}\\nMore details:\\n${errorResponse.errorDescription},`, \n        // @ts-expect-error - TypeScript does not recognize this until we use ES2022 as the target; however, all our major runtimes do support the `cause` property\n        options);\n        this.statusCode = statusCode;\n        this.errorResponse = errorResponse;\n        // Ensure that this type reports the correct name\n        this.name = AuthenticationErrorName;\n    }\n}\n/**\n * The Error.name value of an AggregateAuthenticationError\n */\nexport const AggregateAuthenticationErrorName = \"AggregateAuthenticationError\";\n/**\n * Provides an `errors` array containing {@link AuthenticationError} instance\n * for authentication failures from credentials in a {@link ChainedTokenCredential}.\n */\nexport class AggregateAuthenticationError extends Error {\n    constructor(errors, errorMessage) {\n        const errorDetail = errors.join(\"\\n\");\n        super(`${errorMessage}\\n${errorDetail}`);\n        this.errors = errors;\n        // Ensure that this type reports the correct name\n        this.name = AggregateAuthenticationErrorName;\n    }\n}\nfunction convertOAuthErrorResponseToErrorResponse(errorBody) {\n    return {\n        error: errorBody.error,\n        errorDescription: errorBody.error_description,\n        correlationId: errorBody.correlation_id,\n        errorCodes: errorBody.error_codes,\n        timestamp: errorBody.timestamp,\n        traceId: errorBody.trace_id,\n    };\n}\n/**\n * Error used to enforce authentication after trying to retrieve a token silently.\n */\nexport class AuthenticationRequiredError extends Error {\n    constructor(\n    /**\n     * Optional parameters. A message can be specified. The {@link GetTokenOptions} of the request can also be specified to more easily associate the error with the received parameters.\n     */\n    options) {\n        super(options.message, \n        // @ts-expect-error - TypeScript does not recognize this until we use ES2022 as the target; however, all our major runtimes do support the `cause` property\n        options.cause ? { cause: options.cause } : undefined);\n        this.scopes = options.scopes;\n        this.getTokenOptions = options.getTokenOptions;\n        this.name = \"AuthenticationRequiredError\";\n    }\n}\n//# sourceMappingURL=errors.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Current version of the `@azure/identity` package.\n */\nexport const SDK_VERSION = `4.10.0`;\n/**\n * The default client ID for authentication\n * @internal\n */\n// TODO: temporary - this is the Azure CLI clientID - we'll replace it when\n// Developer Sign On application is available\n// https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/Constants.cs#L9\nexport const DeveloperSignOnClientId = \"04b07795-8ddb-461a-bbee-02f9e1bf7b46\";\n/**\n * The default tenant for authentication\n * @internal\n */\nexport const DefaultTenantId = \"common\";\n/**\n * A list of known Azure authority hosts\n */\nexport var AzureAuthorityHosts;\n(function (AzureAuthorityHosts) {\n    /**\n     * China-based Azure Authority Host\n     */\n    AzureAuthorityHosts[\"AzureChina\"] = \"https://login.chinacloudapi.cn\";\n    /**\n     * Germany-based Azure Authority Host\n     *\n     * @deprecated Microsoft Cloud Germany was closed on October 29th, 2021.\n     *\n     * */\n    AzureAuthorityHosts[\"AzureGermany\"] = \"https://login.microsoftonline.de\";\n    /**\n     * US Government Azure Authority Host\n     */\n    AzureAuthorityHosts[\"AzureGovernment\"] = \"https://login.microsoftonline.us\";\n    /**\n     * Public Cloud Azure Authority Host\n     */\n    AzureAuthorityHosts[\"AzurePublicCloud\"] = \"https://login.microsoftonline.com\";\n})(AzureAuthorityHosts || (AzureAuthorityHosts = {}));\n/**\n * @internal\n * The default authority host.\n */\nexport const DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;\n/**\n * @internal\n * The default environment host for Azure Public Cloud\n */\nexport const DefaultAuthority = \"login.microsoftonline.com\";\n/**\n * @internal\n * Allow acquiring tokens for any tenant for multi-tentant auth.\n */\nexport const ALL_TENANTS = [\"*\"];\n/**\n * @internal\n */\nexport const CACHE_CAE_SUFFIX = \"cae\";\n/**\n * @internal\n */\nexport const CACHE_NON_CAE_SUFFIX = \"nocae\";\n/**\n * @internal\n *\n * The default name for the cache persistence plugin.\n * Matches the constant defined in the cache persistence package.\n */\nexport const DEFAULT_TOKEN_CACHE_NAME = \"msal.cache\";\n//# sourceMappingURL=constants.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/** @internal */\nexport const knownContextKeys = {\n    span: Symbol.for(\"@azure/core-tracing span\"),\n    namespace: Symbol.for(\"@azure/core-tracing namespace\"),\n};\n/**\n * Creates a new {@link TracingContext} with the given options.\n * @param options - A set of known keys that may be set on the context.\n * @returns A new {@link TracingContext} with the given options.\n *\n * @internal\n */\nexport function createTracingContext(options = {}) {\n    let context = new TracingContextImpl(options.parentContext);\n    if (options.span) {\n        context = context.setValue(knownContextKeys.span, options.span);\n    }\n    if (options.namespace) {\n        context = context.setValue(knownContextKeys.namespace, options.namespace);\n    }\n    return context;\n}\n/** @internal */\nexport class TracingContextImpl {\n    constructor(initialContext) {\n        this._contextMap =\n            initialContext instanceof TracingContextImpl\n                ? new Map(initialContext._contextMap)\n                : new Map();\n    }\n    setValue(key, value) {\n        const newContext = new TracingContextImpl(this);\n        newContext._contextMap.set(key, value);\n        return newContext;\n    }\n    getValue(key) {\n        return this._contextMap.get(key);\n    }\n    deleteValue(key) {\n        const newContext = new TracingContextImpl(this);\n        newContext._contextMap.delete(key);\n        return newContext;\n    }\n}\n//# sourceMappingURL=tracingContext.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Browser-only implementation of the module's state. The browser esm variant will not load the commonjs state, so we do not need to share state between the two.\n */\nexport const state = {\n    instrumenterImplementation: undefined,\n};\n//# sourceMappingURL=state-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTracingContext } from \"./tracingContext.js\";\nimport { state } from \"./state.js\";\nexport function createDefaultTracingSpan() {\n    return {\n        end: () => {\n            // noop\n        },\n        isRecording: () => false,\n        recordException: () => {\n            // noop\n        },\n        setAttribute: () => {\n            // noop\n        },\n        setStatus: () => {\n            // noop\n        },\n        addEvent: () => {\n            // noop\n        },\n    };\n}\nexport function createDefaultInstrumenter() {\n    return {\n        createRequestHeaders: () => {\n            return {};\n        },\n        parseTraceparentHeader: () => {\n            return undefined;\n        },\n        startSpan: (_name, spanOptions) => {\n            return {\n                span: createDefaultTracingSpan(),\n                tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext }),\n            };\n        },\n        withContext(_context, callback, ...callbackArgs) {\n            return callback(...callbackArgs);\n        },\n    };\n}\n/**\n * Extends the Azure SDK with support for a given instrumenter implementation.\n *\n * @param instrumenter - The instrumenter implementation to use.\n */\nexport function useInstrumenter(instrumenter) {\n    state.instrumenterImplementation = instrumenter;\n}\n/**\n * Gets the currently set instrumenter, a No-Op instrumenter by default.\n *\n * @returns The currently set instrumenter\n */\nexport function getInstrumenter() {\n    if (!state.instrumenterImplementation) {\n        state.instrumenterImplementation = createDefaultInstrumenter();\n    }\n    return state.instrumenterImplementation;\n}\n//# sourceMappingURL=instrumenter.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getInstrumenter } from \"./instrumenter.js\";\nimport { knownContextKeys } from \"./tracingContext.js\";\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options) {\n    const { namespace, packageName, packageVersion } = options;\n    function startSpan(name, operationOptions, spanOptions) {\n        var _a;\n        const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName: packageName, packageVersion: packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext }));\n        let tracingContext = startSpanResult.tracingContext;\n        const span = startSpanResult.span;\n        if (!tracingContext.getValue(knownContextKeys.namespace)) {\n            tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n        }\n        span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n        const updatedOptions = Object.assign({}, operationOptions, {\n            tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext }),\n        });\n        return {\n            span,\n            updatedOptions,\n        };\n    }\n    async function withSpan(name, operationOptions, callback, spanOptions) {\n        const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);\n        try {\n            const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));\n            span.setStatus({ status: \"success\" });\n            return result;\n        }\n        catch (err) {\n            span.setStatus({ status: \"error\", error: err });\n            throw err;\n        }\n        finally {\n            span.end();\n        }\n    }\n    function withContext(context, callback, ...callbackArgs) {\n        return getInstrumenter().withContext(context, callback, ...callbackArgs);\n    }\n    /**\n     * Parses a traceparent header value into a span identifier.\n     *\n     * @param traceparentHeader - The traceparent header to parse.\n     * @returns An implementation-specific identifier for the span.\n     */\n    function parseTraceparentHeader(traceparentHeader) {\n        return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n    }\n    /**\n     * Creates a set of request headers to propagate tracing information to a backend.\n     *\n     * @param tracingContext - The context containing the span to serialize.\n     * @returns The set of headers to add to a request.\n     */\n    function createRequestHeaders(tracingContext) {\n        return getInstrumenter().createRequestHeaders(tracingContext);\n    }\n    return {\n        startSpan,\n        withSpan,\n        withContext,\n        parseTraceparentHeader,\n        createRequestHeaders,\n    };\n}\n//# sourceMappingURL=tracingClient.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { SDK_VERSION } from \"../constants.js\";\nimport { createTracingClient } from \"@azure/core-tracing\";\n/**\n * Creates a span using the global tracer.\n * @internal\n */\nexport const tracingClient = createTracingClient({\n    namespace: \"Microsoft.AAD\",\n    packageName: \"@azure/identity\",\n    packageVersion: SDK_VERSION,\n});\n//# sourceMappingURL=tracing.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors.js\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging.js\";\nimport { tracingClient } from \"../util/tracing.js\";\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order until\n * one of the getToken methods returns an access token. For more information, see\n * [ChainedTokenCredential overview](https://aka.ms/azsdk/js/identity/credential-chains#use-chainedtokencredential-for-granularity).\n */\nexport class ChainedTokenCredential {\n    /**\n     * Creates an instance of ChainedTokenCredential using the given credentials.\n     *\n     * @param sources - `TokenCredential` implementations to be tried in order.\n     *\n     * Example usage:\n     * ```ts snippet:chained_token_credential_example\n     * import { ClientSecretCredential, ChainedTokenCredential } from \"@azure/identity\";\n     *\n     * const tenantId = \"<tenant-id>\";\n     * const clientId = \"<client-id>\";\n     * const clientSecret = \"<client-secret>\";\n     * const anotherClientId = \"<another-client-id>\";\n     * const anotherSecret = \"<another-client-secret>\";\n     *\n     * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n     * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n     *\n     * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n     * ```\n     */\n    constructor(...sources) {\n        this._sources = [];\n        this._sources = sources;\n    }\n    /**\n     * Returns the first access token returned by one of the chained\n     * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n     * when one or more credentials throws an {@link AuthenticationError} and\n     * no credentials have returned an access token.\n     *\n     * This method is called automatically by Azure SDK client libraries. You may call this method\n     * directly, but you must also handle token caching and token refreshing.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                `TokenCredential` implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        const { token } = await this.getTokenInternal(scopes, options);\n        return token;\n    }\n    async getTokenInternal(scopes, options = {}) {\n        let token = null;\n        let successfulCredential;\n        const errors = [];\n        return tracingClient.withSpan(\"ChainedTokenCredential.getToken\", options, async (updatedOptions) => {\n            for (let i = 0; i < this._sources.length && token === null; i++) {\n                try {\n                    token = await this._sources[i].getToken(scopes, updatedOptions);\n                    successfulCredential = this._sources[i];\n                }\n                catch (err) {\n                    if (err.name === \"CredentialUnavailableError\" ||\n                        err.name === \"AuthenticationRequiredError\") {\n                        errors.push(err);\n                    }\n                    else {\n                        logger.getToken.info(formatError(scopes, err));\n                        throw err;\n                    }\n                }\n            }\n            if (!token && errors.length > 0) {\n                const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n                logger.getToken.info(formatError(scopes, err));\n                throw err;\n            }\n            logger.getToken.info(`Result for ${successfulCredential.constructor.name}: ${formatSuccess(scopes)}`);\n            if (token === null) {\n                throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n            }\n            return { token, successfulCredential };\n        });\n    }\n}\n//# sourceMappingURL=chainedTokenCredential.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nimport { ChainedTokenCredential } from \"./chainedTokenCredential.js\";\nconst BrowserNotSupportedError = new Error(\"DefaultAzureCredential is not supported in the browser. Use InteractiveBrowserCredential instead.\");\nconst logger = credentialLogger(\"DefaultAzureCredential\");\n/**\n * Provides a default {@link ChainedTokenCredential} configuration for\n * applications that will be deployed to Azure.\n *\n * Only available in Node.js.\n */\nexport class DefaultAzureCredential extends ChainedTokenCredential {\n    /**\n     * Creates an instance of the DefaultAzureCredential class.\n     *\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(_tokenCredentialOptions) {\n        super();\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=defaultAzureCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * This error is thrown when an asynchronous operation has been aborted.\n * Check for this error by testing the `name` that the name property of the\n * error matches `\"AbortError\"`.\n *\n * @example\n * ```ts\n * const controller = new AbortController();\n * controller.abort();\n * try {\n *   doAsyncWork(controller.signal)\n * } catch (e) {\n *   if (e.name === 'AbortError') {\n *     // handle abort error here.\n *   }\n * }\n * ```\n */\nexport class AbortError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"AbortError\";\n    }\n}\n//# sourceMappingURL=AbortError.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AbortError } from \"@azure/abort-controller\";\n/**\n * Creates an abortable promise.\n * @param buildPromise - A function that takes the resolve and reject functions as parameters.\n * @param options - The options for the abortable promise.\n * @returns A promise that can be aborted.\n */\nexport function createAbortablePromise(buildPromise, options) {\n    const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};\n    return new Promise((resolve, reject) => {\n        function rejectOnAbort() {\n            reject(new AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : \"The operation was aborted.\"));\n        }\n        function removeListeners() {\n            abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", onAbort);\n        }\n        function onAbort() {\n            cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 ? void 0 : cleanupBeforeAbort();\n            removeListeners();\n            rejectOnAbort();\n        }\n        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n            return rejectOnAbort();\n        }\n        try {\n            buildPromise((x) => {\n                removeListeners();\n                resolve(x);\n            }, (x) => {\n                removeListeners();\n                reject(x);\n            });\n        }\n        catch (err) {\n            reject(err);\n        }\n        abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener(\"abort\", onAbort);\n    });\n}\n//# sourceMappingURL=createAbortablePromise.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createAbortablePromise } from \"./createAbortablePromise.js\";\nimport { getRandomIntegerInclusive } from \"@typespec/ts-http-runtime/internal/util\";\nconst StandardAbortMessage = \"The delay was aborted.\";\n/**\n * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.\n * @param timeInMs - The number of milliseconds to be delayed.\n * @param options - The options for delay - currently abort options\n * @returns Promise that is resolved after timeInMs\n */\nexport function delay(timeInMs, options) {\n    let token;\n    const { abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};\n    return createAbortablePromise((resolve) => {\n        token = setTimeout(resolve, timeInMs);\n    }, {\n        cleanupBeforeAbort: () => clearTimeout(token),\n        abortSignal,\n        abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage,\n    });\n}\n/**\n * Calculates the delay interval for retry attempts using exponential delay with jitter.\n * @param retryAttempt - The current retry attempt number.\n * @param config - The exponential retry configuration.\n * @returns An object containing the calculated retry delay.\n */\nexport function calculateRetryDelay(retryAttempt, config) {\n    // Exponentially increase the delay each time\n    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);\n    // Don't let the delay exceed the maximum\n    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);\n    // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n    // that retries across multiple clients don't occur simultaneously.\n    const retryAfterInMs = clampedDelay / 2 + getRandomIntegerInclusive(0, clampedDelay / 2);\n    return { retryAfterInMs };\n}\n//# sourceMappingURL=delay.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isError } from \"@typespec/ts-http-runtime/internal/util\";\n/**\n * Given what is thought to be an error object, return the message if possible.\n * If the message is missing, returns a stringified version of the input.\n * @param e - Something thrown from a try block\n * @returns The error message or a string of the input\n */\nexport function getErrorMessage(e) {\n    if (isError(e)) {\n        return e.message;\n    }\n    else {\n        let stringified;\n        try {\n            if (typeof e === \"object\" && e) {\n                stringified = JSON.stringify(e);\n            }\n            else {\n                stringified = String(e);\n            }\n        }\n        catch (err) {\n            stringified = \"[unable to stringify input]\";\n        }\n        return `Unknown error ${stringified}`;\n    }\n}\n//# sourceMappingURL=error.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport * as tspRuntime from \"@typespec/ts-http-runtime/internal/util\";\nexport { cancelablePromiseRace, } from \"./aborterUtils.js\";\nexport { createAbortablePromise, } from \"./createAbortablePromise.js\";\nexport { delay } from \"./delay.js\";\nexport { getErrorMessage } from \"./error.js\";\nexport { isDefined, isObjectWithProperties, objectHasProperty } from \"./typeGuards.js\";\n/**\n * Calculates the delay interval for retry attempts using exponential delay with jitter.\n *\n * @param retryAttempt - The current retry attempt number.\n *\n * @param config - The exponential retry configuration.\n *\n * @returns An object containing the calculated retry delay.\n */\nexport function calculateRetryDelay(retryAttempt, config) {\n    return tspRuntime.calculateRetryDelay(retryAttempt, config);\n}\n/**\n * Generates a SHA-256 hash.\n *\n * @param content - The data to be included in the hash.\n *\n * @param encoding - The textual encoding to use for the returned hash.\n */\nexport function computeSha256Hash(content, encoding) {\n    return tspRuntime.computeSha256Hash(content, encoding);\n}\n/**\n * Generates a SHA-256 HMAC signature.\n *\n * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.\n *\n * @param stringToSign - The data to be signed.\n *\n * @param encoding - The textual encoding to use for the returned HMAC digest.\n */\nexport function computeSha256Hmac(key, stringToSign, encoding) {\n    return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);\n}\n/**\n * Returns a random integer value between a lower and upper bound, inclusive of both bounds. Note that this uses Math.random and isn't secure. If you need to use this for any kind of security purpose, find a better source of random.\n *\n * @param min - The smallest integer value allowed.\n *\n * @param max - The largest integer value allowed.\n */\nexport function getRandomIntegerInclusive(min, max) {\n    return tspRuntime.getRandomIntegerInclusive(min, max);\n}\n/**\n * Typeguard for an error object shape (has name and message)\n *\n * @param e - Something caught by a catch clause.\n */\nexport function isError(e) {\n    return tspRuntime.isError(e);\n}\n/**\n * Helper to determine when an input is a generic JS object.\n *\n * @returns true when input is an object type that is not null, Array, RegExp, or Date.\n */\nexport function isObject(input) {\n    return tspRuntime.isObject(input);\n}\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function randomUUID() {\n    return tspRuntime.randomUUID();\n}\n/**\n * A constant that indicates whether the environment the code is running is a Web Browser.\n */\nexport const isBrowser = tspRuntime.isBrowser;\n/**\n * A constant that indicates whether the environment the code is running is Bun.sh.\n */\nexport const isBun = tspRuntime.isBun;\n/**\n * A constant that indicates whether the environment the code is running is Deno.\n */\nexport const isDeno = tspRuntime.isDeno;\n/**\n * A constant that indicates whether the environment the code is running is a Node.js compatible environment.\n *\n * @deprecated\n *\n * Use `isNodeLike` instead.\n */\nexport const isNode = tspRuntime.isNodeLike;\n/**\n * A constant that indicates whether the environment the code is running is a Node.js compatible environment.\n */\nexport const isNodeLike = tspRuntime.isNodeLike;\n/**\n * A constant that indicates whether the environment the code is running is Node.JS.\n */\nexport const isNodeRuntime = tspRuntime.isNodeRuntime;\n/**\n * A constant that indicates whether the environment the code is running is in React-Native.\n */\nexport const isReactNative = tspRuntime.isReactNative;\n/**\n * A constant that indicates whether the environment the code is running is a Web Worker.\n */\nexport const isWebWorker = tspRuntime.isWebWorker;\n/**\n * The helper that transforms bytes with specific character encoding into string\n * @param bytes - the uint8array bytes\n * @param format - the format we use to encode the byte\n * @returns a string of the encoded string\n */\nexport function uint8ArrayToString(bytes, format) {\n    return tspRuntime.uint8ArrayToString(bytes, format);\n}\n/**\n * The helper that transforms string to specific character encoded bytes array.\n * @param value - the string to be converted\n * @param format - the format we use to decode the value\n * @returns a uint8array\n */\nexport function stringToUint8Array(value, format) {\n    return tspRuntime.stringToUint8Array(value, format);\n}\n//# sourceMappingURL=index.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../errors.js\";\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nimport { DefaultAuthority, DefaultAuthorityHost, DefaultTenantId } from \"../constants.js\";\nimport { randomUUID as coreRandomUUID, isNode, isNodeLike } from \"@azure/core-util\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { msalCommon } from \"./msal.js\";\n/**\n * @internal\n */\nconst logger = credentialLogger(\"IdentityUtils\");\n/**\n * Latest AuthenticationRecord version\n * @internal\n */\nconst LatestAuthenticationRecordVersion = \"1.0\";\n/**\n * Ensures the validity of the MSAL token\n * @internal\n */\nexport function ensureValidMsalToken(scopes, msalToken, getTokenOptions) {\n    const error = (message) => {\n        logger.getToken.info(message);\n        return new AuthenticationRequiredError({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            getTokenOptions,\n            message,\n        });\n    };\n    if (!msalToken) {\n        throw error(\"No response\");\n    }\n    if (!msalToken.expiresOn) {\n        throw error(`Response had no \"expiresOn\" property.`);\n    }\n    if (!msalToken.accessToken) {\n        throw error(`Response had no \"accessToken\" property.`);\n    }\n}\n/**\n * Returns the authority host from either the options bag or the AZURE_AUTHORITY_HOST environment variable.\n *\n * Defaults to {@link DefaultAuthorityHost}.\n * @internal\n */\nexport function getAuthorityHost(options) {\n    let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n    if (!authorityHost && isNodeLike) {\n        authorityHost = process.env.AZURE_AUTHORITY_HOST;\n    }\n    return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * Generates a valid authority by combining a host with a tenantId.\n * @internal\n */\nexport function getAuthority(tenantId, host) {\n    if (!host) {\n        host = DefaultAuthorityHost;\n    }\n    if (new RegExp(`${tenantId}/?$`).test(host)) {\n        return host;\n    }\n    if (host.endsWith(\"/\")) {\n        return host + tenantId;\n    }\n    else {\n        return `${host}/${tenantId}`;\n    }\n}\n/**\n * Generates the known authorities.\n * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.\n * For that reason, we have to force MSAL to disable validating the authority\n * by sending it within the known authorities in the MSAL configuration.\n * @internal\n */\nexport function getKnownAuthorities(tenantId, authorityHost, disableInstanceDiscovery) {\n    if ((tenantId === \"adfs\" && authorityHost) || disableInstanceDiscovery) {\n        return [authorityHost];\n    }\n    return [];\n}\n/**\n * Generates a logger that can be passed to the MSAL clients.\n * @param credLogger - The logger of the credential.\n * @internal\n */\nexport const defaultLoggerCallback = (credLogger, platform = isNode ? \"Node\" : \"Browser\") => (level, message, containsPii) => {\n    if (containsPii) {\n        return;\n    }\n    switch (level) {\n        case msalCommon.LogLevel.Error:\n            credLogger.info(`MSAL ${platform} V2 error: ${message}`);\n            return;\n        case msalCommon.LogLevel.Info:\n            credLogger.info(`MSAL ${platform} V2 info message: ${message}`);\n            return;\n        case msalCommon.LogLevel.Verbose:\n            credLogger.info(`MSAL ${platform} V2 verbose message: ${message}`);\n            return;\n        case msalCommon.LogLevel.Warning:\n            credLogger.info(`MSAL ${platform} V2 warning: ${message}`);\n            return;\n    }\n};\n/**\n * @internal\n */\nexport function getMSALLogLevel(logLevel) {\n    switch (logLevel) {\n        case \"error\":\n            return msalCommon.LogLevel.Error;\n        case \"info\":\n            return msalCommon.LogLevel.Info;\n        case \"verbose\":\n            return msalCommon.LogLevel.Verbose;\n        case \"warning\":\n            return msalCommon.LogLevel.Warning;\n        default:\n            // default msal logging level should be Info\n            return msalCommon.LogLevel.Info;\n    }\n}\n/**\n * Wraps core-util's randomUUID in order to allow for mocking in tests.\n * This prepares the library for the upcoming core-util update to ESM.\n *\n * @internal\n * @returns A string containing a random UUID\n */\nexport function randomUUID() {\n    return coreRandomUUID();\n}\n/**\n * Handles MSAL errors.\n */\nexport function handleMsalError(scopes, error, getTokenOptions) {\n    if (error.name === \"AuthError\" ||\n        error.name === \"ClientAuthError\" ||\n        error.name === \"BrowserAuthError\") {\n        const msalError = error;\n        switch (msalError.errorCode) {\n            case \"endpoints_resolution_error\":\n                logger.info(formatError(scopes, error.message));\n                return new CredentialUnavailableError(error.message);\n            case \"device_code_polling_cancelled\":\n                return new AbortError(\"The authentication has been aborted by the caller.\");\n            case \"consent_required\":\n            case \"interaction_required\":\n            case \"login_required\":\n                logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));\n                break;\n            default:\n                logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));\n                break;\n        }\n    }\n    if (error.name === \"ClientConfigurationError\" ||\n        error.name === \"BrowserConfigurationAuthError\" ||\n        error.name === \"AbortError\" ||\n        error.name === \"AuthenticationError\") {\n        return error;\n    }\n    if (error.name === \"NativeAuthError\") {\n        logger.info(formatError(scopes, `Error from the native broker: ${error.message} with status code: ${error.statusCode}`));\n        return error;\n    }\n    return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });\n}\n// transformations\nexport function publicToMsal(account) {\n    return {\n        localAccountId: account.homeAccountId,\n        environment: account.authority,\n        username: account.username,\n        homeAccountId: account.homeAccountId,\n        tenantId: account.tenantId,\n    };\n}\nexport function msalToPublic(clientId, account) {\n    var _a;\n    const record = {\n        authority: (_a = account.environment) !== null && _a !== void 0 ? _a : DefaultAuthority,\n        homeAccountId: account.homeAccountId,\n        tenantId: account.tenantId || DefaultTenantId,\n        username: account.username,\n        clientId,\n        version: LatestAuthenticationRecordVersion,\n    };\n    return record;\n}\n/**\n * Serializes an `AuthenticationRecord` into a string.\n *\n * The output of a serialized authentication record will contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.\n */\nexport function serializeAuthenticationRecord(record) {\n    return JSON.stringify(record);\n}\n/**\n * Deserializes a previously serialized authentication record from a string into an object.\n *\n * The input string must contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * If the version we receive is unsupported, an error will be thrown.\n *\n * At the moment, the only available version is: \"1.0\", which is always set when the authentication record is serialized.\n *\n * @param serializedRecord - Authentication record previously serialized into string.\n * @returns AuthenticationRecord.\n */\nexport function deserializeAuthenticationRecord(serializedRecord) {\n    const parsed = JSON.parse(serializedRecord);\n    if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {\n        throw Error(\"Unsupported AuthenticationRecord version\");\n    }\n    return parsed;\n}\n//# sourceMappingURL=utils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createEmptyPipeline as tspCreateEmptyPipeline } from \"@typespec/ts-http-runtime\";\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline() {\n    return tspCreateEmptyPipeline();\n}\n//# sourceMappingURL=pipeline.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-rest-pipeline\");\n//# sourceMappingURL=log.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { logger as coreLogger } from \"../log.js\";\nimport { logPolicyName as tspLogPolicyName, logPolicy as tspLogPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * The programmatic identifier of the logPolicy.\n */\nexport const logPolicyName = tspLogPolicyName;\n/**\n * A policy that logs all requests and responses.\n * @param options - Options to configure logPolicy.\n */\nexport function logPolicy(options = {}) {\n    return tspLogPolicy(Object.assign({ logger: coreLogger.info }, options));\n}\n//# sourceMappingURL=logPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { redirectPolicyName as tspRedirectPolicyName, redirectPolicy as tspRedirectPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * The programmatic identifier of the redirectPolicy.\n */\nexport const redirectPolicyName = tspRedirectPolicyName;\n/**\n * A policy to follow Location headers from the server in order\n * to support server-side redirection.\n * In the browser, this policy is not used.\n * @param options - Options to control policy behavior.\n */\nexport function redirectPolicy(options = {}) {\n    return tspRedirectPolicy(options);\n}\n//# sourceMappingURL=redirectPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * @internal\n */\nexport function getHeaderName() {\n    return \"x-ms-useragent\";\n}\nfunction getBrowserInfo(userAgent) {\n    const browserRegexes = [\n        { name: \"Firefox\", regex: /Firefox\\/([\\d.]+)/ },\n        { name: \"Safari\", regex: /Version\\/([\\d.]+).*Safari/ },\n    ];\n    for (const browser of browserRegexes) {\n        const match = userAgent.match(browser.regex);\n        if (match) {\n            return { brand: browser.name, version: match[1] };\n        }\n    }\n    return undefined;\n}\nfunction getBrandVersionString(brands) {\n    const brandOrder = [\"Google Chrome\", \"Microsoft Edge\", \"Opera\", \"Brave\", \"Chromium\"];\n    for (const brand of brandOrder) {\n        const foundBrand = brands.find((b) => b.brand === brand);\n        if (foundBrand) {\n            return foundBrand;\n        }\n    }\n    return undefined;\n}\n/**\n * @internal\n */\nexport async function setPlatformSpecificData(map) {\n    const localNavigator = globalThis.navigator;\n    let osPlatform = \"unknown\";\n    if (localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.userAgentData) {\n        const entropyValues = await localNavigator.userAgentData.getHighEntropyValues([\n            \"architecture\",\n            \"platformVersion\",\n        ]);\n        osPlatform = `${entropyValues.architecture}-${entropyValues.platform}-${entropyValues.platformVersion}`;\n        // Get the brand and version\n        const brand = getBrandVersionString(localNavigator.userAgentData.brands);\n        if (brand) {\n            map.set(brand.brand, brand.version);\n        }\n    }\n    else if (localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.platform) {\n        osPlatform = localNavigator.platform;\n        const brand = getBrowserInfo(localNavigator.userAgent);\n        if (brand) {\n            map.set(brand.brand, brand.version);\n        }\n    }\n    else if (typeof globalThis.EdgeRuntime === \"string\") {\n        map.set(\"EdgeRuntime\", globalThis.EdgeRuntime);\n    }\n    map.set(\"OS\", osPlatform);\n}\n//# sourceMappingURL=userAgentPlatform-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport const SDK_VERSION = \"1.21.0\";\nexport const DEFAULT_RETRY_POLICY_COUNT = 3;\n//# sourceMappingURL=constants.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getHeaderName, setPlatformSpecificData } from \"./userAgentPlatform.js\";\nimport { SDK_VERSION } from \"../constants.js\";\nfunction getUserAgentString(telemetryInfo) {\n    const parts = [];\n    for (const [key, value] of telemetryInfo) {\n        const token = value ? `${key}/${value}` : key;\n        parts.push(token);\n    }\n    return parts.join(\" \");\n}\n/**\n * @internal\n */\nexport function getUserAgentHeaderName() {\n    return getHeaderName();\n}\n/**\n * @internal\n */\nexport async function getUserAgentValue(prefix) {\n    const runtimeInfo = new Map();\n    runtimeInfo.set(\"core-rest-pipeline\", SDK_VERSION);\n    await setPlatformSpecificData(runtimeInfo);\n    const defaultAgent = getUserAgentString(runtimeInfo);\n    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;\n    return userAgentValue;\n}\n//# sourceMappingURL=userAgent.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getUserAgentHeaderName, getUserAgentValue } from \"../util/userAgent.js\";\nconst UserAgentHeaderName = getUserAgentHeaderName();\n/**\n * The programmatic identifier of the userAgentPolicy.\n */\nexport const userAgentPolicyName = \"userAgentPolicy\";\n/**\n * A policy that sets the User-Agent header (or equivalent) to reflect\n * the library version.\n * @param options - Options to customize the user agent value.\n */\nexport function userAgentPolicy(options = {}) {\n    const userAgentValue = getUserAgentValue(options.userAgentPrefix);\n    return {\n        name: userAgentPolicyName,\n        async sendRequest(request, next) {\n            if (!request.headers.has(UserAgentHeaderName)) {\n                request.headers.set(UserAgentHeaderName, await userAgentValue);\n            }\n            return next(request);\n        },\n    };\n}\n//# sourceMappingURL=userAgentPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isNodeLike } from \"@azure/core-util\";\nfunction isNodeReadableStream(x) {\n    return Boolean(x && typeof x[\"pipe\"] === \"function\");\n}\nconst unimplementedMethods = {\n    arrayBuffer: () => {\n        throw new Error(\"Not implemented\");\n    },\n    bytes: () => {\n        throw new Error(\"Not implemented\");\n    },\n    slice: () => {\n        throw new Error(\"Not implemented\");\n    },\n    text: () => {\n        throw new Error(\"Not implemented\");\n    },\n};\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent = Symbol(\"rawContent\");\n/**\n * Type guard to check if a given object is a blob-like object with a raw content property.\n */\nexport function hasRawContent(x) {\n    return typeof x[rawContent] === \"function\";\n}\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the actual blob.\n *\n * @internal\n */\nexport function getRawContent(blob) {\n    if (hasRawContent(blob)) {\n        return blob[rawContent]();\n    }\n    else {\n        return blob;\n    }\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(stream, name, options = {}) {\n    var _a, _b, _c, _d;\n    return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a = options.type) !== null && _a !== void 0 ? _a : \"\", lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(), webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : \"\", size: (_d = options.size) !== null && _d !== void 0 ? _d : -1, name, stream: () => {\n            const s = stream();\n            if (isNodeReadableStream(s)) {\n                throw new Error(\"Not supported: a Node stream was provided as input to createFileFromStream.\");\n            }\n            return s;\n        }, [rawContent]: stream });\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(content, name, options = {}) {\n    var _a, _b, _c;\n    if (isNodeLike) {\n        return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a = options.type) !== null && _a !== void 0 ? _a : \"\", lastModified: (_b = options.lastModified) !== null && _b !== void 0 ? _b : new Date().getTime(), webkitRelativePath: (_c = options.webkitRelativePath) !== null && _c !== void 0 ? _c : \"\", size: content.byteLength, name, arrayBuffer: async () => content.buffer, stream: () => new Blob([content]).stream(), [rawContent]: () => content });\n    }\n    else {\n        return new File([content], name, options);\n    }\n}\n//# sourceMappingURL=file.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { multipartPolicyName as tspMultipartPolicyName, multipartPolicy as tspMultipartPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\nimport { getRawContent, hasRawContent } from \"../util/file.js\";\n/**\n * Name of multipart policy\n */\nexport const multipartPolicyName = tspMultipartPolicyName;\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy() {\n    const tspPolicy = tspMultipartPolicy();\n    return {\n        name: multipartPolicyName,\n        sendRequest: async (request, next) => {\n            if (request.multipartBody) {\n                for (const part of request.multipartBody.parts) {\n                    if (hasRawContent(part.body)) {\n                        part.body = getRawContent(part.body);\n                    }\n                }\n            }\n            return tspPolicy.sendRequest(request, next);\n        },\n    };\n}\n//# sourceMappingURL=multipartPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { decompressResponsePolicyName as tspDecompressResponsePolicyName, decompressResponsePolicy as tspDecompressResponsePolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * The programmatic identifier of the decompressResponsePolicy.\n */\nexport const decompressResponsePolicyName = tspDecompressResponsePolicyName;\n/**\n * A policy to enable response decompression according to Accept-Encoding header\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding\n */\nexport function decompressResponsePolicy() {\n    return tspDecompressResponsePolicy();\n}\n//# sourceMappingURL=decompressResponsePolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { defaultRetryPolicyName as tspDefaultRetryPolicyName, defaultRetryPolicy as tspDefaultRetryPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * Name of the {@link defaultRetryPolicy}\n */\nexport const defaultRetryPolicyName = tspDefaultRetryPolicyName;\n/**\n * A policy that retries according to three strategies:\n * - When the server sends a 429 response with a Retry-After header.\n * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).\n * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.\n */\nexport function defaultRetryPolicy(options = {}) {\n    return tspDefaultRetryPolicy(options);\n}\n//# sourceMappingURL=defaultRetryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { formDataPolicyName as tspFormDataPolicyName, formDataPolicy as tspFormDataPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = tspFormDataPolicyName;\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy() {\n    return tspFormDataPolicy();\n}\n//# sourceMappingURL=formDataPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { proxyPolicy as tspProxyPolicy, proxyPolicyName as tspProxyPolicyName, getDefaultProxySettings as tspGetDefaultProxySettings, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * The programmatic identifier of the proxyPolicy.\n */\nexport const proxyPolicyName = tspProxyPolicyName;\n/**\n * This method converts a proxy url into `ProxySettings` for use with ProxyPolicy.\n * If no argument is given, it attempts to parse a proxy URL from the environment\n * variables `HTTPS_PROXY` or `HTTP_PROXY`.\n * @param proxyUrl - The url of the proxy to use. May contain authentication information.\n * @deprecated - Internally this method is no longer necessary when setting proxy information.\n */\nexport function getDefaultProxySettings(proxyUrl) {\n    return tspGetDefaultProxySettings(proxyUrl);\n}\n/**\n * A policy that allows one to apply proxy settings to all requests.\n * If not passed static settings, they will be retrieved from the HTTPS_PROXY\n * or HTTP_PROXY environment variables.\n * @param proxySettings - ProxySettings to use on each request.\n * @param options - additional settings, for example, custom NO_PROXY patterns\n */\nexport function proxyPolicy(proxySettings, options) {\n    return tspProxyPolicy(proxySettings, options);\n}\n//# sourceMappingURL=proxyPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * The programmatic identifier of the setClientRequestIdPolicy.\n */\nexport const setClientRequestIdPolicyName = \"setClientRequestIdPolicy\";\n/**\n * Each PipelineRequest gets a unique id upon creation.\n * This policy passes that unique id along via an HTTP header to enable better\n * telemetry and tracing.\n * @param requestIdHeaderName - The name of the header to pass the request ID to.\n */\nexport function setClientRequestIdPolicy(requestIdHeaderName = \"x-ms-client-request-id\") {\n    return {\n        name: setClientRequestIdPolicyName,\n        async sendRequest(request, next) {\n            if (!request.headers.has(requestIdHeaderName)) {\n                request.headers.set(requestIdHeaderName, request.requestId);\n            }\n            return next(request);\n        },\n    };\n}\n//# sourceMappingURL=setClientRequestIdPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { agentPolicyName as tspAgentPolicyName, agentPolicy as tspAgentPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * Name of the Agent Policy\n */\nexport const agentPolicyName = tspAgentPolicyName;\n/**\n * Gets a pipeline policy that sets http.agent\n */\nexport function agentPolicy(agent) {\n    return tspAgentPolicy(agent);\n}\n//# sourceMappingURL=agentPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { tlsPolicy as tspTlsPolicy, tlsPolicyName as tspTlsPolicyName, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * Name of the TLS Policy\n */\nexport const tlsPolicyName = tspTlsPolicyName;\n/**\n * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.\n */\nexport function tlsPolicy(tlsSettings) {\n    return tspTlsPolicy(tlsSettings);\n}\n//# sourceMappingURL=tlsPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { RestError as TspRestError, isRestError as tspIsRestError, } from \"@typespec/ts-http-runtime\";\n/**\n * A custom error type for failed pipeline requests.\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const RestError = TspRestError;\n/**\n * Typeguard for RestError\n * @param e - Something caught by a catch clause.\n */\nexport function isRestError(e) {\n    return tspIsRestError(e);\n}\n//# sourceMappingURL=restError.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTracingClient, } from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants.js\";\nimport { getUserAgentValue } from \"../util/userAgent.js\";\nimport { logger } from \"../log.js\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError.js\";\nimport { Sanitizer } from \"@typespec/ts-http-runtime/internal/util\";\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options = {}) {\n    const userAgentPromise = getUserAgentValue(options.userAgentPrefix);\n    const sanitizer = new Sanitizer({\n        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,\n    });\n    const tracingClient = tryCreateTracingClient();\n    return {\n        name: tracingPolicyName,\n        async sendRequest(request, next) {\n            var _a;\n            if (!tracingClient) {\n                return next(request);\n            }\n            const userAgent = await userAgentPromise;\n            const spanAttributes = {\n                \"http.url\": sanitizer.sanitizeUrl(request.url),\n                \"http.method\": request.method,\n                \"http.user_agent\": userAgent,\n                requestId: request.requestId,\n            };\n            if (userAgent) {\n                spanAttributes[\"http.user_agent\"] = userAgent;\n            }\n            const { span, tracingContext } = (_a = tryCreateSpan(tracingClient, request, spanAttributes)) !== null && _a !== void 0 ? _a : {};\n            if (!span || !tracingContext) {\n                return next(request);\n            }\n            try {\n                const response = await tracingClient.withContext(tracingContext, next, request);\n                tryProcessResponse(span, response);\n                return response;\n            }\n            catch (err) {\n                tryProcessError(span, err);\n                throw err;\n            }\n        },\n    };\n}\nfunction tryCreateTracingClient() {\n    try {\n        return createTracingClient({\n            namespace: \"\",\n            packageName: \"@azure/core-rest-pipeline\",\n            packageVersion: SDK_VERSION,\n        });\n    }\n    catch (e) {\n        logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n        return undefined;\n    }\n}\nfunction tryCreateSpan(tracingClient, request, spanAttributes) {\n    try {\n        // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n        const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {\n            spanKind: \"client\",\n            spanAttributes,\n        });\n        // If the span is not recording, don't do any more work.\n        if (!span.isRecording()) {\n            span.end();\n            return undefined;\n        }\n        // set headers\n        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);\n        for (const [key, value] of Object.entries(headers)) {\n            request.headers.set(key, value);\n        }\n        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };\n    }\n    catch (e) {\n        logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n        return undefined;\n    }\n}\nfunction tryProcessError(span, error) {\n    try {\n        span.setStatus({\n            status: \"error\",\n            error: isError(error) ? error : undefined,\n        });\n        if (isRestError(error) && error.statusCode) {\n            span.setAttribute(\"http.status_code\", error.statusCode);\n        }\n        span.end();\n    }\n    catch (e) {\n        logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n    }\n}\nfunction tryProcessResponse(span, response) {\n    try {\n        span.setAttribute(\"http.status_code\", response.status);\n        const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n        if (serviceRequestId) {\n            span.setAttribute(\"serviceRequestId\", serviceRequestId);\n        }\n        // Per semantic conventions, only set the status to error if the status code is 4xx or 5xx.\n        // Otherwise, the status MUST remain unset.\n        // https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status\n        if (response.status >= 400) {\n            span.setStatus({\n                status: \"error\",\n            });\n        }\n        span.end();\n    }\n    catch (e) {\n        logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n    }\n}\n//# sourceMappingURL=tracingPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Creates a native AbortSignal which reflects the state of the provided AbortSignalLike.\n * If the AbortSignalLike is already a native AbortSignal, it is returned as is.\n * @param abortSignalLike - The AbortSignalLike to wrap.\n * @returns - An object containing the native AbortSignal and an optional cleanup function. The cleanup function should be called when the AbortSignal is no longer needed.\n */\nexport function wrapAbortSignalLike(abortSignalLike) {\n    if (abortSignalLike instanceof AbortSignal) {\n        return { abortSignal: abortSignalLike };\n    }\n    if (abortSignalLike.aborted) {\n        return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };\n    }\n    const controller = new AbortController();\n    let needsCleanup = true;\n    function cleanup() {\n        if (needsCleanup) {\n            abortSignalLike.removeEventListener(\"abort\", listener);\n            needsCleanup = false;\n        }\n    }\n    function listener() {\n        controller.abort(abortSignalLike.reason);\n        cleanup();\n    }\n    abortSignalLike.addEventListener(\"abort\", listener);\n    return { abortSignal: controller.signal, cleanup };\n}\n//# sourceMappingURL=wrapAbortSignal.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { wrapAbortSignalLike } from \"../util/wrapAbortSignal.js\";\nexport const wrapAbortSignalLikePolicyName = \"wrapAbortSignalLikePolicy\";\n/**\n * Policy that ensure that any AbortSignalLike is wrapped in a native AbortSignal for processing by the pipeline.\n * Since the ts-http-runtime expects a native AbortSignal, this policy is used to ensure that any AbortSignalLike is wrapped in a native AbortSignal.\n *\n * @returns - created policy\n */\nexport function wrapAbortSignalLikePolicy() {\n    return {\n        name: wrapAbortSignalLikePolicyName,\n        sendRequest: async (request, next) => {\n            if (!request.abortSignal) {\n                return next(request);\n            }\n            const { abortSignal, cleanup } = wrapAbortSignalLike(request.abortSignal);\n            // eslint-disable-next-line no-param-reassign\n            request.abortSignal = abortSignal;\n            try {\n                return await next(request);\n            }\n            finally {\n                cleanup === null || cleanup === void 0 ? void 0 : cleanup();\n            }\n        },\n    };\n}\n//# sourceMappingURL=wrapAbortSignalLikePolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { logPolicy } from \"./policies/logPolicy.js\";\nimport { createEmptyPipeline } from \"./pipeline.js\";\nimport { redirectPolicy } from \"./policies/redirectPolicy.js\";\nimport { userAgentPolicy } from \"./policies/userAgentPolicy.js\";\nimport { multipartPolicy, multipartPolicyName } from \"./policies/multipartPolicy.js\";\nimport { decompressResponsePolicy } from \"./policies/decompressResponsePolicy.js\";\nimport { defaultRetryPolicy } from \"./policies/defaultRetryPolicy.js\";\nimport { formDataPolicy } from \"./policies/formDataPolicy.js\";\nimport { isNodeLike } from \"@azure/core-util\";\nimport { proxyPolicy } from \"./policies/proxyPolicy.js\";\nimport { setClientRequestIdPolicy } from \"./policies/setClientRequestIdPolicy.js\";\nimport { agentPolicy } from \"./policies/agentPolicy.js\";\nimport { tlsPolicy } from \"./policies/tlsPolicy.js\";\nimport { tracingPolicy } from \"./policies/tracingPolicy.js\";\nimport { wrapAbortSignalLikePolicy } from \"./policies/wrapAbortSignalLikePolicy.js\";\n/**\n * Create a new pipeline with a default set of customizable policies.\n * @param options - Options to configure a custom pipeline.\n */\nexport function createPipelineFromOptions(options) {\n    var _a;\n    const pipeline = createEmptyPipeline();\n    if (isNodeLike) {\n        if (options.agent) {\n            pipeline.addPolicy(agentPolicy(options.agent));\n        }\n        if (options.tlsOptions) {\n            pipeline.addPolicy(tlsPolicy(options.tlsOptions));\n        }\n        pipeline.addPolicy(proxyPolicy(options.proxyOptions));\n        pipeline.addPolicy(decompressResponsePolicy());\n    }\n    pipeline.addPolicy(wrapAbortSignalLikePolicy());\n    pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });\n    pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));\n    pipeline.addPolicy(setClientRequestIdPolicy((_a = options.telemetryOptions) === null || _a === void 0 ? void 0 : _a.clientRequestIdHeaderName));\n    // The multipart policy is added after policies with no phase, so that\n    // policies can be added between it and formDataPolicy to modify\n    // properties (e.g., making the boundary constant in recorded tests).\n    pipeline.addPolicy(multipartPolicy(), { afterPhase: \"Deserialize\" });\n    pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: \"Retry\" });\n    pipeline.addPolicy(tracingPolicy(Object.assign(Object.assign({}, options.userAgentOptions), options.loggingOptions)), {\n        afterPhase: \"Retry\",\n    });\n    if (isNodeLike) {\n        // Both XHR and Fetch expect to handle redirects automatically,\n        // so only include this policy when we're in Node.\n        pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: \"Retry\" });\n    }\n    pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: \"Sign\" });\n    return pipeline;\n}\n//# sourceMappingURL=createPipelineFromOptions.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createDefaultHttpClient as tspCreateDefaultHttpClient } from \"@typespec/ts-http-runtime\";\nimport { wrapAbortSignalLike } from \"./util/wrapAbortSignal.js\";\n/**\n * Create the correct HttpClient for the current environment.\n */\nexport function createDefaultHttpClient() {\n    const client = tspCreateDefaultHttpClient();\n    return {\n        async sendRequest(request) {\n            // we wrap any AbortSignalLike here since the TypeSpec runtime expects a native AbortSignal.\n            // 99% of the time, this should be a no-op since a native AbortSignal is passed in.\n            const { abortSignal, cleanup } = request.abortSignal\n                ? wrapAbortSignalLike(request.abortSignal)\n                : {};\n            try {\n                // eslint-disable-next-line no-param-reassign\n                request.abortSignal = abortSignal;\n                return await client.sendRequest(request);\n            }\n            finally {\n                cleanup === null || cleanup === void 0 ? void 0 : cleanup();\n            }\n        },\n    };\n}\n//# sourceMappingURL=defaultHttpClient.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createHttpHeaders as tspCreateHttpHeaders } from \"@typespec/ts-http-runtime\";\n/**\n * Creates an object that satisfies the `HttpHeaders` interface.\n * @param rawHeaders - A simple object representing initial headers\n */\nexport function createHttpHeaders(rawHeaders) {\n    return tspCreateHttpHeaders(rawHeaders);\n}\n//# sourceMappingURL=httpHeaders.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createPipelineRequest as tspCreatePipelineRequest, } from \"@typespec/ts-http-runtime\";\n/**\n * Creates a new pipeline request with the given options.\n * This method is to allow for the easy setting of default values and not required.\n * @param options - The options to create the request with.\n */\nexport function createPipelineRequest(options) {\n    // Cast required due to difference between ts-http-runtime requiring AbortSignal while core-rest-pipeline allows\n    // the more generic AbortSignalLike. The wrapAbortSignalLike pipeline policy will take care of ensuring that any AbortSignalLike in the request\n    // is converted into a true AbortSignal.\n    return tspCreatePipelineRequest(options);\n}\n//# sourceMappingURL=pipelineRequest.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { exponentialRetryPolicyName as tspExponentialRetryPolicyName, exponentialRetryPolicy as tspExponentialRetryPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * The programmatic identifier of the exponentialRetryPolicy.\n */\nexport const exponentialRetryPolicyName = tspExponentialRetryPolicyName;\n/**\n * A policy that attempts to retry requests while introducing an exponentially increasing delay.\n * @param options - Options that configure retry logic.\n */\nexport function exponentialRetryPolicy(options = {}) {\n    return tspExponentialRetryPolicy(options);\n}\n//# sourceMappingURL=exponentialRetryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { systemErrorRetryPolicy as tspSystemErrorRetryPolicy, systemErrorRetryPolicyName as tspSystemErrorRetryPolicyName, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * Name of the {@link systemErrorRetryPolicy}\n */\nexport const systemErrorRetryPolicyName = tspSystemErrorRetryPolicyName;\n/**\n * A retry policy that specifically seeks to handle errors in the\n * underlying transport layer (e.g. DNS lookup failures) rather than\n * retryable error codes from the server itself.\n * @param options - Options that customize the policy.\n */\nexport function systemErrorRetryPolicy(options = {}) {\n    return tspSystemErrorRetryPolicy(options);\n}\n//# sourceMappingURL=systemErrorRetryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { throttlingRetryPolicyName as tspThrottlingRetryPolicyName, throttlingRetryPolicy as tspThrottlingRetryPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\n/**\n * Name of the {@link throttlingRetryPolicy}\n */\nexport const throttlingRetryPolicyName = tspThrottlingRetryPolicyName;\n/**\n * A policy that retries when the server sends a 429 response with a Retry-After header.\n *\n * To learn more, please refer to\n * https://learn.microsoft.com/azure/azure-resource-manager/resource-manager-request-limits,\n * https://learn.microsoft.com/azure/azure-subscription-service-limits and\n * https://learn.microsoft.com/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n *\n * @param options - Options that configure retry logic.\n */\nexport function throttlingRetryPolicy(options = {}) {\n    return tspThrottlingRetryPolicy(options);\n}\n//# sourceMappingURL=throttlingRetryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\nimport { retryPolicy as tspRetryPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {\n    // Cast is required since the TSP runtime retry strategy type is slightly different\n    // very deep down (using real AbortSignal vs. AbortSignalLike in RestError).\n    // In practice the difference doesn't actually matter.\n    return tspRetryPolicy(strategies, Object.assign({ logger: retryPolicyLogger }, options));\n}\n//# sourceMappingURL=retryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { delay } from \"@azure/core-util\";\n// Default options for the cycler if none are provided\nexport const DEFAULT_CYCLER_OPTIONS = {\n    forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires\n    retryIntervalInMs: 3000, // Allow refresh attempts every 3s\n    refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry\n};\n/**\n * Converts an an unreliable access token getter (which may resolve with null)\n * into an AccessTokenGetter by retrying the unreliable getter in a regular\n * interval.\n *\n * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.\n * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.\n * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.\n * @returns - A promise that, if it resolves, will resolve with an access token.\n */\nasync function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {\n    // This wrapper handles exceptions gracefully as long as we haven't exceeded\n    // the timeout.\n    async function tryGetAccessToken() {\n        if (Date.now() < refreshTimeout) {\n            try {\n                return await getAccessToken();\n            }\n            catch (_a) {\n                return null;\n            }\n        }\n        else {\n            const finalToken = await getAccessToken();\n            // Timeout is up, so throw if it's still null\n            if (finalToken === null) {\n                throw new Error(\"Failed to refresh access token.\");\n            }\n            return finalToken;\n        }\n    }\n    let token = await tryGetAccessToken();\n    while (token === null) {\n        await delay(retryIntervalInMs);\n        token = await tryGetAccessToken();\n    }\n    return token;\n}\n/**\n * Creates a token cycler from a credential, scopes, and optional settings.\n *\n * A token cycler represents a way to reliably retrieve a valid access token\n * from a TokenCredential. It will handle initializing the token, refreshing it\n * when it nears expiration, and synchronizes refresh attempts to avoid\n * concurrency hazards.\n *\n * @param credential - the underlying TokenCredential that provides the access\n * token\n * @param tokenCyclerOptions - optionally override default settings for the cycler\n *\n * @returns - a function that reliably produces a valid access token\n */\nexport function createTokenCycler(credential, tokenCyclerOptions) {\n    let refreshWorker = null;\n    let token = null;\n    let tenantId;\n    const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);\n    /**\n     * This little holder defines several predicates that we use to construct\n     * the rules of refreshing the token.\n     */\n    const cycler = {\n        /**\n         * Produces true if a refresh job is currently in progress.\n         */\n        get isRefreshing() {\n            return refreshWorker !== null;\n        },\n        /**\n         * Produces true if the cycler SHOULD refresh (we are within the refresh\n         * window and not already refreshing)\n         */\n        get shouldRefresh() {\n            var _a;\n            if (cycler.isRefreshing) {\n                return false;\n            }\n            if ((token === null || token === void 0 ? void 0 : token.refreshAfterTimestamp) && token.refreshAfterTimestamp < Date.now()) {\n                return true;\n            }\n            return ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now();\n        },\n        /**\n         * Produces true if the cycler MUST refresh (null or nearly-expired\n         * token).\n         */\n        get mustRefresh() {\n            return (token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now());\n        },\n    };\n    /**\n     * Starts a refresh job or returns the existing job if one is already\n     * running.\n     */\n    function refresh(scopes, getTokenOptions) {\n        var _a;\n        if (!cycler.isRefreshing) {\n            // We bind `scopes` here to avoid passing it around a lot\n            const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);\n            // Take advantage of promise chaining to insert an assignment to `token`\n            // before the refresh can be considered done.\n            refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, \n            // If we don't have a token, then we should timeout immediately\n            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now())\n                .then((_token) => {\n                refreshWorker = null;\n                token = _token;\n                tenantId = getTokenOptions.tenantId;\n                return token;\n            })\n                .catch((reason) => {\n                // We also should reset the refresher if we enter a failed state.  All\n                // existing awaiters will throw, but subsequent requests will start a\n                // new retry chain.\n                refreshWorker = null;\n                token = null;\n                tenantId = undefined;\n                throw reason;\n            });\n        }\n        return refreshWorker;\n    }\n    return async (scopes, tokenOptions) => {\n        //\n        // Simple rules:\n        // - If we MUST refresh, then return the refresh task, blocking\n        //   the pipeline until a token is available.\n        // - If we SHOULD refresh, then run refresh but don't return it\n        //   (we can still use the cached token).\n        // - Return the token, since it's fine if we didn't return in\n        //   step 1.\n        //\n        const hasClaimChallenge = Boolean(tokenOptions.claims);\n        const tenantIdChanged = tenantId !== tokenOptions.tenantId;\n        if (hasClaimChallenge) {\n            // If we've received a claim, we know the existing token isn't valid\n            // We want to clear it so that that refresh worker won't use the old expiration time as a timeout\n            token = null;\n        }\n        // If the tenantId passed in token options is different to the one we have\n        // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to\n        // refresh the token with the new tenantId or token.\n        const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;\n        if (mustRefresh) {\n            return refresh(scopes, tokenOptions);\n        }\n        if (cycler.shouldRefresh) {\n            refresh(scopes, tokenOptions);\n        }\n        return token;\n    };\n}\n//# sourceMappingURL=tokenCycler.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\nimport { isRestError } from \"../restError.js\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Try to send the given request.\n *\n * When a response is received, returns a tuple of the response received and, if the response was received\n * inside a thrown RestError, the RestError that was thrown.\n *\n * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it\n * will be rethrown.\n */\nasync function trySendRequest(request, next) {\n    try {\n        return [await next(request), undefined];\n    }\n    catch (e) {\n        if (isRestError(e) && e.response) {\n            return [e.response, e];\n        }\n        else {\n            throw e;\n        }\n    }\n}\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options) {\n    const { scopes, getAccessToken, request } = options;\n    // Enable CAE true by default\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n        enableCae: true,\n    };\n    const accessToken = await getAccessToken(scopes, getTokenOptions);\n    if (accessToken) {\n        options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction isChallengeResponse(response) {\n    return response.status === 401 && response.headers.has(\"WWW-Authenticate\");\n}\n/**\n * Re-authorize the request for CAE challenge.\n * The response containing the challenge is `options.response`.\n * If this method returns true, the underlying request will be sent once again.\n */\nasync function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {\n    var _a;\n    const { scopes } = onChallengeOptions;\n    const accessToken = await onChallengeOptions.getAccessToken(scopes, {\n        enableCae: true,\n        claims: caeClaims,\n    });\n    if (!accessToken) {\n        return false;\n    }\n    onChallengeOptions.request.headers.set(\"Authorization\", `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n    return true;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n    var _a, _b, _c;\n    const { credential, scopes, challengeCallbacks } = options;\n    const logger = options.logger || coreLogger;\n    const callbacks = {\n        authorizeRequest: (_b = (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) === null || _a === void 0 ? void 0 : _a.bind(challengeCallbacks)) !== null && _b !== void 0 ? _b : defaultAuthorizeRequest,\n        authorizeRequestOnChallenge: (_c = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge) === null || _c === void 0 ? void 0 : _c.bind(challengeCallbacks),\n    };\n    // This function encapsulates the entire process of reliably retrieving the token\n    // The options are left out of the public API until there's demand to configure this.\n    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n    // in order to pass through the `options` object.\n    const getAccessToken = credential\n        ? createTokenCycler(credential /* , options */)\n        : () => Promise.resolve(null);\n    return {\n        name: bearerTokenAuthenticationPolicyName,\n        /**\n         * If there's no challenge parameter:\n         * - It will try to retrieve the token using the cache, or the credential's getToken.\n         * - Then it will try the next policy with or without the retrieved token.\n         *\n         * It uses the challenge parameters to:\n         * - Skip a first attempt to get the token from the credential if there's no cached token,\n         *   since it expects the token to be retrievable only after the challenge.\n         * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n         * - Send an initial request to receive the challenge if it fails.\n         * - Process a challenge if the response contains it.\n         * - Retrieve a token with the challenge information, then re-send the request.\n         */\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            await callbacks.authorizeRequest({\n                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                request,\n                getAccessToken,\n                logger,\n            });\n            let response;\n            let error;\n            let shouldSendRequest;\n            [response, error] = await trySendRequest(request, next);\n            if (isChallengeResponse(response)) {\n                let claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n                // Handle CAE by default when receive CAE claim\n                if (claims) {\n                    let parsedClaim;\n                    // Return the response immediately if claims is not a valid base64 encoded string\n                    try {\n                        parsedClaim = atob(claims);\n                    }\n                    catch (e) {\n                        logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n                        return response;\n                    }\n                    shouldSendRequest = await authorizeRequestOnCaeChallenge({\n                        scopes: Array.isArray(scopes) ? scopes : [scopes],\n                        response,\n                        request,\n                        getAccessToken,\n                        logger,\n                    }, parsedClaim);\n                    // Send updated request and handle response for RestError\n                    if (shouldSendRequest) {\n                        [response, error] = await trySendRequest(request, next);\n                    }\n                }\n                else if (callbacks.authorizeRequestOnChallenge) {\n                    // Handle custom challenges when client provides custom callback\n                    shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n                        scopes: Array.isArray(scopes) ? scopes : [scopes],\n                        request,\n                        response,\n                        getAccessToken,\n                        logger,\n                    });\n                    // Send updated request and handle response for RestError\n                    if (shouldSendRequest) {\n                        [response, error] = await trySendRequest(request, next);\n                    }\n                    // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this\n                    if (isChallengeResponse(response)) {\n                        claims = getCaeChallengeClaims(response.headers.get(\"WWW-Authenticate\"));\n                        if (claims) {\n                            let parsedClaim;\n                            try {\n                                parsedClaim = atob(claims);\n                            }\n                            catch (e) {\n                                logger.warning(`The WWW-Authenticate header contains \"claims\" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);\n                                return response;\n                            }\n                            shouldSendRequest = await authorizeRequestOnCaeChallenge({\n                                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                                response,\n                                request,\n                                getAccessToken,\n                                logger,\n                            }, parsedClaim);\n                            // Send updated request and handle response for RestError\n                            if (shouldSendRequest) {\n                                [response, error] = await trySendRequest(request, next);\n                            }\n                        }\n                    }\n                }\n            }\n            if (error) {\n                throw error;\n            }\n            else {\n                return response;\n            }\n        },\n    };\n}\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Pop e=\"f\", g=\"h\"`.\n * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.\n *\n * @internal\n */\nexport function parseChallenges(challenges) {\n    // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a=\"b\", c=d`\n    // The challenge regex captures parameteres with either quotes values or unquoted values\n    const challengeRegex = /(\\w+)\\s+((?:\\w+=(?:\"[^\"]*\"|[^,]*),?\\s*)+)/g;\n    // Parameter regex captures the claims group removed from the scheme in the format `a=\"b\"` and `c=\"d\"`\n    // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge\n    const paramRegex = /(\\w+)=\"([^\"]*)\"/g;\n    const parsedChallenges = [];\n    let match;\n    // Iterate over each challenge match\n    while ((match = challengeRegex.exec(challenges)) !== null) {\n        const scheme = match[1];\n        const paramsString = match[2];\n        const params = {};\n        let paramMatch;\n        // Iterate over each parameter match\n        while ((paramMatch = paramRegex.exec(paramsString)) !== null) {\n            params[paramMatch[1]] = paramMatch[2];\n        }\n        parsedChallenges.push({ scheme, params });\n    }\n    return parsedChallenges;\n}\n/**\n * Parse a pipeline response and look for a CAE challenge with \"Bearer\" scheme\n * Return the value in the header without parsing the challenge\n * @internal\n */\nfunction getCaeChallengeClaims(challenges) {\n    var _a;\n    if (!challenges) {\n        return;\n    }\n    // Find all challenges present in the header\n    const parsedChallenges = parseChallenges(challenges);\n    return (_a = parsedChallenges.find((x) => x.scheme === \"Bearer\" && x.params.claims && x.params.error === \"insufficient_claims\")) === null || _a === void 0 ? void 0 : _a.params.claims;\n}\n//# sourceMappingURL=bearerTokenAuthenticationPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createTokenCycler } from \"../util/tokenCycler.js\";\nimport { logger as coreLogger } from \"../log.js\";\n/**\n * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.\n */\nexport const auxiliaryAuthenticationHeaderPolicyName = \"auxiliaryAuthenticationHeaderPolicy\";\nconst AUTHORIZATION_AUXILIARY_HEADER = \"x-ms-authorization-auxiliary\";\nasync function sendAuthorizeRequest(options) {\n    var _a, _b;\n    const { scopes, getAccessToken, request } = options;\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n    };\n    return (_b = (_a = (await getAccessToken(scopes, getTokenOptions))) === null || _a === void 0 ? void 0 : _a.token) !== null && _b !== void 0 ? _b : \"\";\n}\n/**\n * A policy for external tokens to `x-ms-authorization-auxiliary` header.\n * This header will be used when creating a cross-tenant application we may need to handle authentication requests\n * for resources that are in different tenants.\n * You could see [ARM docs](https://learn.microsoft.com/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works\n */\nexport function auxiliaryAuthenticationHeaderPolicy(options) {\n    const { credentials, scopes } = options;\n    const logger = options.logger || coreLogger;\n    const tokenCyclerMap = new WeakMap();\n    return {\n        name: auxiliaryAuthenticationHeaderPolicyName,\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            if (!credentials || credentials.length === 0) {\n                logger.info(`${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);\n                return next(request);\n            }\n            const tokenPromises = [];\n            for (const credential of credentials) {\n                let getAccessToken = tokenCyclerMap.get(credential);\n                if (!getAccessToken) {\n                    getAccessToken = createTokenCycler(credential);\n                    tokenCyclerMap.set(credential, getAccessToken);\n                }\n                tokenPromises.push(sendAuthorizeRequest({\n                    scopes: Array.isArray(scopes) ? scopes : [scopes],\n                    request,\n                    getAccessToken,\n                    logger,\n                }));\n            }\n            const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));\n            if (auxiliaryTokens.length === 0) {\n                logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);\n                return next(request);\n            }\n            request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(\", \"));\n            return next(request);\n        },\n    };\n}\n//# sourceMappingURL=auxiliaryAuthenticationHeaderPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { ALL_TENANTS, DeveloperSignOnClientId } from \"../constants.js\";\nimport { formatError } from \"./logging.js\";\nexport { processMultiTenantRequest } from \"./processMultiTenantRequest.js\";\n/**\n * @internal\n */\nexport function checkTenantId(logger, tenantId) {\n    if (!tenantId.match(/^[0-9a-zA-Z-.]+$/)) {\n        const error = new Error(\"Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://learn.microsoft.com/partner-center/find-ids-and-domain-names.\");\n        logger.info(formatError(\"\", error));\n        throw error;\n    }\n}\n/**\n * @internal\n */\nexport function resolveTenantId(logger, tenantId, clientId) {\n    if (tenantId) {\n        checkTenantId(logger, tenantId);\n        return tenantId;\n    }\n    if (!clientId) {\n        clientId = DeveloperSignOnClientId;\n    }\n    if (clientId !== DeveloperSignOnClientId) {\n        return \"common\";\n    }\n    return \"organizations\";\n}\n/**\n * @internal\n */\nexport function resolveAdditionallyAllowedTenantIds(additionallyAllowedTenants) {\n    if (!additionallyAllowedTenants || additionallyAllowedTenants.length === 0) {\n        return [];\n    }\n    if (additionallyAllowedTenants.includes(\"*\")) {\n        return ALL_TENANTS;\n    }\n    return additionallyAllowedTenants;\n}\n//# sourceMappingURL=tenantIdUtils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport * as base64 from \"./base64.js\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { isDuration, isValidUuid } from \"./utils.js\";\nclass SerializerImpl {\n    constructor(modelMappers = {}, isXML = false) {\n        this.modelMappers = modelMappers;\n        this.isXML = isXML;\n    }\n    /**\n     * @deprecated Removing the constraints validation on client side.\n     */\n    validateConstraints(mapper, value, objectName) {\n        const failValidation = (constraintName, constraintValue) => {\n            throw new Error(`\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`);\n        };\n        if (mapper.constraints && value !== undefined && value !== null) {\n            const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems, } = mapper.constraints;\n            if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {\n                failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n            }\n            if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {\n                failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n            }\n            if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {\n                failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n            }\n            if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {\n                failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n            }\n            if (MaxItems !== undefined && value.length > MaxItems) {\n                failValidation(\"MaxItems\", MaxItems);\n            }\n            if (MaxLength !== undefined && value.length > MaxLength) {\n                failValidation(\"MaxLength\", MaxLength);\n            }\n            if (MinItems !== undefined && value.length < MinItems) {\n                failValidation(\"MinItems\", MinItems);\n            }\n            if (MinLength !== undefined && value.length < MinLength) {\n                failValidation(\"MinLength\", MinLength);\n            }\n            if (MultipleOf !== undefined && value % MultipleOf !== 0) {\n                failValidation(\"MultipleOf\", MultipleOf);\n            }\n            if (Pattern) {\n                const pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n                if (typeof value !== \"string\" || value.match(pattern) === null) {\n                    failValidation(\"Pattern\", Pattern);\n                }\n            }\n            if (UniqueItems &&\n                value.some((item, i, ar) => ar.indexOf(item) !== i)) {\n                failValidation(\"UniqueItems\", UniqueItems);\n            }\n        }\n    }\n    /**\n     * Serialize the given object based on its metadata defined in the mapper\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object\n     *\n     * @param object - A valid Javascript object to be serialized\n     *\n     * @param objectName - Name of the serialized object\n     *\n     * @param options - additional options to serialization\n     *\n     * @returns A valid serialized Javascript object\n     */\n    serialize(mapper, object, objectName, options = { xml: {} }) {\n        var _a, _b, _c;\n        const updatedOptions = {\n            xml: {\n                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,\n            },\n        };\n        let payload = {};\n        const mapperType = mapper.type.name;\n        if (!objectName) {\n            objectName = mapper.serializedName;\n        }\n        if (mapperType.match(/^Sequence$/i) !== null) {\n            payload = [];\n        }\n        if (mapper.isConstant) {\n            object = mapper.defaultValue;\n        }\n        // This table of allowed values should help explain\n        // the mapper.required and mapper.nullable properties.\n        // X means \"neither undefined or null are allowed\".\n        //           || required\n        //           || true      | false\n        //  nullable || ==========================\n        //      true || null      | undefined/null\n        //     false || X         | undefined\n        // undefined || X         | undefined/null\n        const { required, nullable } = mapper;\n        if (required && nullable && object === undefined) {\n            throw new Error(`${objectName} cannot be undefined.`);\n        }\n        if (required && !nullable && (object === undefined || object === null)) {\n            throw new Error(`${objectName} cannot be null or undefined.`);\n        }\n        if (!required && nullable === false && object === null) {\n            throw new Error(`${objectName} cannot be null.`);\n        }\n        if (object === undefined || object === null) {\n            payload = object;\n        }\n        else {\n            if (mapperType.match(/^any$/i) !== null) {\n                payload = object;\n            }\n            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n                payload = serializeBasicTypes(mapperType, objectName, object);\n            }\n            else if (mapperType.match(/^Enum$/i) !== null) {\n                const enumMapper = mapper;\n                payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n            }\n            else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {\n                payload = serializeDateTypes(mapperType, object, objectName);\n            }\n            else if (mapperType.match(/^ByteArray$/i) !== null) {\n                payload = serializeByteArrayType(objectName, object);\n            }\n            else if (mapperType.match(/^Base64Url$/i) !== null) {\n                payload = serializeBase64UrlType(objectName, object);\n            }\n            else if (mapperType.match(/^Sequence$/i) !== null) {\n                payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n            }\n            else if (mapperType.match(/^Dictionary$/i) !== null) {\n                payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n            }\n            else if (mapperType.match(/^Composite$/i) !== null) {\n                payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n            }\n        }\n        return payload;\n    }\n    /**\n     * Deserialize the given object based on its metadata defined in the mapper\n     *\n     * @param mapper - The mapper which defines the metadata of the serializable object\n     *\n     * @param responseBody - A valid Javascript entity to be deserialized\n     *\n     * @param objectName - Name of the deserialized object\n     *\n     * @param options - Controls behavior of XML parser and builder.\n     *\n     * @returns A valid deserialized Javascript object\n     */\n    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {\n        var _a, _b, _c, _d;\n        const updatedOptions = {\n            xml: {\n                rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : \"\",\n                includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,\n                xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY,\n            },\n            ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false,\n        };\n        if (responseBody === undefined || responseBody === null) {\n            if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n                // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n                // between the list being empty versus being missing,\n                // so let's do the more user-friendly thing and return an empty list.\n                responseBody = [];\n            }\n            // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n            if (mapper.defaultValue !== undefined) {\n                responseBody = mapper.defaultValue;\n            }\n            return responseBody;\n        }\n        let payload;\n        const mapperType = mapper.type.name;\n        if (!objectName) {\n            objectName = mapper.serializedName;\n        }\n        if (mapperType.match(/^Composite$/i) !== null) {\n            payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);\n        }\n        else {\n            if (this.isXML) {\n                const xmlCharKey = updatedOptions.xml.xmlCharKey;\n                /**\n                 * If the mapper specifies this as a non-composite type value but the responseBody contains\n                 * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n                 * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n                 */\n                if (responseBody[XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {\n                    responseBody = responseBody[xmlCharKey];\n                }\n            }\n            if (mapperType.match(/^Number$/i) !== null) {\n                payload = parseFloat(responseBody);\n                if (isNaN(payload)) {\n                    payload = responseBody;\n                }\n            }\n            else if (mapperType.match(/^Boolean$/i) !== null) {\n                if (responseBody === \"true\") {\n                    payload = true;\n                }\n                else if (responseBody === \"false\") {\n                    payload = false;\n                }\n                else {\n                    payload = responseBody;\n                }\n            }\n            else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n                payload = responseBody;\n            }\n            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n                payload = new Date(responseBody);\n            }\n            else if (mapperType.match(/^UnixTime$/i) !== null) {\n                payload = unixTimeToDate(responseBody);\n            }\n            else if (mapperType.match(/^ByteArray$/i) !== null) {\n                payload = base64.decodeString(responseBody);\n            }\n            else if (mapperType.match(/^Base64Url$/i) !== null) {\n                payload = base64UrlToByteArray(responseBody);\n            }\n            else if (mapperType.match(/^Sequence$/i) !== null) {\n                payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);\n            }\n            else if (mapperType.match(/^Dictionary$/i) !== null) {\n                payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);\n            }\n        }\n        if (mapper.isConstant) {\n            payload = mapper.defaultValue;\n        }\n        return payload;\n    }\n}\n/**\n * Method that creates and returns a Serializer.\n * @param modelMappers - Known models to map\n * @param isXML - If XML should be supported\n */\nexport function createSerializer(modelMappers = {}, isXML = false) {\n    return new SerializerImpl(modelMappers, isXML);\n}\nfunction trimEnd(str, ch) {\n    let len = str.length;\n    while (len - 1 >= 0 && str[len - 1] === ch) {\n        --len;\n    }\n    return str.substr(0, len);\n}\nfunction bufferToBase64Url(buffer) {\n    if (!buffer) {\n        return undefined;\n    }\n    if (!(buffer instanceof Uint8Array)) {\n        throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n    }\n    // Uint8Array to Base64.\n    const str = base64.encodeByteArray(buffer);\n    // Base64 to Base64Url.\n    return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\nfunction base64UrlToByteArray(str) {\n    if (!str) {\n        return undefined;\n    }\n    if (str && typeof str.valueOf() !== \"string\") {\n        throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n    }\n    // Base64Url to Base64.\n    str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    // Base64 to Uint8Array.\n    return base64.decodeString(str);\n}\nfunction splitSerializeName(prop) {\n    const classes = [];\n    let partialclass = \"\";\n    if (prop) {\n        const subwords = prop.split(\".\");\n        for (const item of subwords) {\n            if (item.charAt(item.length - 1) === \"\\\\\") {\n                partialclass += item.substr(0, item.length - 1) + \".\";\n            }\n            else {\n                partialclass += item;\n                classes.push(partialclass);\n                partialclass = \"\";\n            }\n        }\n    }\n    return classes;\n}\nfunction dateToUnixTime(d) {\n    if (!d) {\n        return undefined;\n    }\n    if (typeof d.valueOf() === \"string\") {\n        d = new Date(d);\n    }\n    return Math.floor(d.getTime() / 1000);\n}\nfunction unixTimeToDate(n) {\n    if (!n) {\n        return undefined;\n    }\n    return new Date(n * 1000);\n}\nfunction serializeBasicTypes(typeName, objectName, value) {\n    if (value !== null && value !== undefined) {\n        if (typeName.match(/^Number$/i) !== null) {\n            if (typeof value !== \"number\") {\n                throw new Error(`${objectName} with value ${value} must be of type number.`);\n            }\n        }\n        else if (typeName.match(/^String$/i) !== null) {\n            if (typeof value.valueOf() !== \"string\") {\n                throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n            }\n        }\n        else if (typeName.match(/^Uuid$/i) !== null) {\n            if (!(typeof value.valueOf() === \"string\" && isValidUuid(value))) {\n                throw new Error(`${objectName} with value \"${value}\" must be of type string and a valid uuid.`);\n            }\n        }\n        else if (typeName.match(/^Boolean$/i) !== null) {\n            if (typeof value !== \"boolean\") {\n                throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n            }\n        }\n        else if (typeName.match(/^Stream$/i) !== null) {\n            const objectType = typeof value;\n            if (objectType !== \"string\" &&\n                typeof value.pipe !== \"function\" && // NodeJS.ReadableStream\n                typeof value.tee !== \"function\" && // browser ReadableStream\n                !(value instanceof ArrayBuffer) &&\n                !ArrayBuffer.isView(value) &&\n                // File objects count as a type of Blob, so we want to use instanceof explicitly\n                !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob) &&\n                objectType !== \"function\") {\n                throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);\n            }\n        }\n    }\n    return value;\n}\nfunction serializeEnumType(objectName, allowedValues, value) {\n    if (!allowedValues) {\n        throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);\n    }\n    const isPresent = allowedValues.some((item) => {\n        if (typeof item.valueOf() === \"string\") {\n            return item.toLowerCase() === value.toLowerCase();\n        }\n        return item === value;\n    });\n    if (!isPresent) {\n        throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);\n    }\n    return value;\n}\nfunction serializeByteArrayType(objectName, value) {\n    if (value !== undefined && value !== null) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error(`${objectName} must be of type Uint8Array.`);\n        }\n        value = base64.encodeByteArray(value);\n    }\n    return value;\n}\nfunction serializeBase64UrlType(objectName, value) {\n    if (value !== undefined && value !== null) {\n        if (!(value instanceof Uint8Array)) {\n            throw new Error(`${objectName} must be of type Uint8Array.`);\n        }\n        value = bufferToBase64Url(value);\n    }\n    return value;\n}\nfunction serializeDateTypes(typeName, value, objectName) {\n    if (value !== undefined && value !== null) {\n        if (typeName.match(/^Date$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n            }\n            value =\n                value instanceof Date\n                    ? value.toISOString().substring(0, 10)\n                    : new Date(value).toISOString().substring(0, 10);\n        }\n        else if (typeName.match(/^DateTime$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n            }\n            value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n        }\n        else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n            }\n            value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n        }\n        else if (typeName.match(/^UnixTime$/i) !== null) {\n            if (!(value instanceof Date ||\n                (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value))))) {\n                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n                    `for it to be serialized in UnixTime/Epoch format.`);\n            }\n            value = dateToUnixTime(value);\n        }\n        else if (typeName.match(/^TimeSpan$/i) !== null) {\n            if (!isDuration(value)) {\n                throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`);\n            }\n        }\n    }\n    return value;\n}\nfunction serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {\n    var _a;\n    if (!Array.isArray(object)) {\n        throw new Error(`${objectName} must be of type Array.`);\n    }\n    let elementType = mapper.type.element;\n    if (!elementType || typeof elementType !== \"object\") {\n        throw new Error(`element\" metadata for an Array must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}.`);\n    }\n    // Quirk: Composite mappers referenced by `element` might\n    // not have *all* properties declared (like uberParent),\n    // so let's try to look up the full definition by name.\n    if (elementType.type.name === \"Composite\" && elementType.type.className) {\n        elementType = (_a = serializer.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;\n    }\n    const tempArray = [];\n    for (let i = 0; i < object.length; i++) {\n        const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n        if (isXml && elementType.xmlNamespace) {\n            const xmlnsKey = elementType.xmlNamespacePrefix\n                ? `xmlns:${elementType.xmlNamespacePrefix}`\n                : \"xmlns\";\n            if (elementType.type.name === \"Composite\") {\n                tempArray[i] = Object.assign({}, serializedValue);\n                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n            }\n            else {\n                tempArray[i] = {};\n                tempArray[i][options.xml.xmlCharKey] = serializedValue;\n                tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n            }\n        }\n        else {\n            tempArray[i] = serializedValue;\n        }\n    }\n    return tempArray;\n}\nfunction serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {\n    if (typeof object !== \"object\") {\n        throw new Error(`${objectName} must be of type object.`);\n    }\n    const valueType = mapper.type.value;\n    if (!valueType || typeof valueType !== \"object\") {\n        throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}.`);\n    }\n    const tempDictionary = {};\n    for (const key of Object.keys(object)) {\n        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n        // If the element needs an XML namespace we need to add it within the $ property\n        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n    }\n    // Add the namespace to the root element if needed\n    if (isXml && mapper.xmlNamespace) {\n        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n        const result = tempDictionary;\n        result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };\n        return result;\n    }\n    return tempDictionary;\n}\n/**\n * Resolves the additionalProperties property from a referenced mapper\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveAdditionalProperties(serializer, mapper, objectName) {\n    const additionalProperties = mapper.type.additionalProperties;\n    if (!additionalProperties && mapper.type.className) {\n        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n        return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;\n    }\n    return additionalProperties;\n}\n/**\n * Finds the mapper referenced by className\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n * @param objectName - name of the object being serialized\n */\nfunction resolveReferencedMapper(serializer, mapper, objectName) {\n    const className = mapper.type.className;\n    if (!className) {\n        throw new Error(`Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(mapper, undefined, 2)}\".`);\n    }\n    return serializer.modelMappers[className];\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - the serializer containing the entire set of mappers\n * @param mapper - the composite mapper to resolve\n */\nfunction resolveModelProperties(serializer, mapper, objectName) {\n    let modelProps = mapper.type.modelProperties;\n    if (!modelProps) {\n        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n        if (!modelMapper) {\n            throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n        }\n        modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;\n        if (!modelProps) {\n            throw new Error(`modelProperties cannot be null or undefined in the ` +\n                `mapper \"${JSON.stringify(modelMapper)}\" of type \"${mapper.type.className}\" for object \"${objectName}\".`);\n        }\n    }\n    return modelProps;\n}\nfunction serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {\n    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n        mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n    }\n    if (object !== undefined && object !== null) {\n        const payload = {};\n        const modelProps = resolveModelProperties(serializer, mapper, objectName);\n        for (const key of Object.keys(modelProps)) {\n            const propertyMapper = modelProps[key];\n            if (propertyMapper.readOnly) {\n                continue;\n            }\n            let propName;\n            let parentObject = payload;\n            if (serializer.isXML) {\n                if (propertyMapper.xmlIsWrapped) {\n                    propName = propertyMapper.xmlName;\n                }\n                else {\n                    propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n                }\n            }\n            else {\n                const paths = splitSerializeName(propertyMapper.serializedName);\n                propName = paths.pop();\n                for (const pathName of paths) {\n                    const childObject = parentObject[pathName];\n                    if ((childObject === undefined || childObject === null) &&\n                        ((object[key] !== undefined && object[key] !== null) ||\n                            propertyMapper.defaultValue !== undefined)) {\n                        parentObject[pathName] = {};\n                    }\n                    parentObject = parentObject[pathName];\n                }\n            }\n            if (parentObject !== undefined && parentObject !== null) {\n                if (isXml && mapper.xmlNamespace) {\n                    const xmlnsKey = mapper.xmlNamespacePrefix\n                        ? `xmlns:${mapper.xmlNamespacePrefix}`\n                        : \"xmlns\";\n                    parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });\n                }\n                const propertyObjectName = propertyMapper.serializedName !== \"\"\n                    ? objectName + \".\" + propertyMapper.serializedName\n                    : objectName;\n                let toSerialize = object[key];\n                const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n                if (polymorphicDiscriminator &&\n                    polymorphicDiscriminator.clientName === key &&\n                    (toSerialize === undefined || toSerialize === null)) {\n                    toSerialize = mapper.serializedName;\n                }\n                const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);\n                if (serializedValue !== undefined && propName !== undefined && propName !== null) {\n                    const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n                    if (isXml && propertyMapper.xmlIsAttribute) {\n                        // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n                        // This keeps things simple while preventing name collision\n                        // with names in user documents.\n                        parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n                        parentObject[XML_ATTRKEY][propName] = serializedValue;\n                    }\n                    else if (isXml && propertyMapper.xmlIsWrapped) {\n                        parentObject[propName] = { [propertyMapper.xmlElementName]: value };\n                    }\n                    else {\n                        parentObject[propName] = value;\n                    }\n                }\n            }\n        }\n        const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n        if (additionalPropertiesMapper) {\n            const propNames = Object.keys(modelProps);\n            for (const clientPropName in object) {\n                const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n                if (isAdditionalProperty) {\n                    payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]', options);\n                }\n            }\n        }\n        return payload;\n    }\n    return object;\n}\nfunction getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {\n    if (!isXml || !propertyMapper.xmlNamespace) {\n        return serializedValue;\n    }\n    const xmlnsKey = propertyMapper.xmlNamespacePrefix\n        ? `xmlns:${propertyMapper.xmlNamespacePrefix}`\n        : \"xmlns\";\n    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };\n    if ([\"Composite\"].includes(propertyMapper.type.name)) {\n        if (serializedValue[XML_ATTRKEY]) {\n            return serializedValue;\n        }\n        else {\n            const result = Object.assign({}, serializedValue);\n            result[XML_ATTRKEY] = xmlNamespace;\n            return result;\n        }\n    }\n    const result = {};\n    result[options.xml.xmlCharKey] = serializedValue;\n    result[XML_ATTRKEY] = xmlNamespace;\n    return result;\n}\nfunction isSpecialXmlProperty(propertyName, options) {\n    return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);\n}\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {\n    var _a, _b;\n    const xmlCharKey = (_a = options.xml.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;\n    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n        mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n    }\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    let instance = {};\n    const handledPropertyNames = [];\n    for (const key of Object.keys(modelProps)) {\n        const propertyMapper = modelProps[key];\n        const paths = splitSerializeName(modelProps[key].serializedName);\n        handledPropertyNames.push(paths[0]);\n        const { serializedName, xmlName, xmlElementName } = propertyMapper;\n        let propertyObjectName = objectName;\n        if (serializedName !== \"\" && serializedName !== undefined) {\n            propertyObjectName = objectName + \".\" + serializedName;\n        }\n        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n        if (headerCollectionPrefix) {\n            const dictionary = {};\n            for (const headerKey of Object.keys(responseBody)) {\n                if (headerKey.startsWith(headerCollectionPrefix)) {\n                    dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);\n                }\n                handledPropertyNames.push(headerKey);\n            }\n            instance[key] = dictionary;\n        }\n        else if (serializer.isXML) {\n            if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n                instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);\n            }\n            else if (propertyMapper.xmlIsMsText) {\n                if (responseBody[xmlCharKey] !== undefined) {\n                    instance[key] = responseBody[xmlCharKey];\n                }\n                else if (typeof responseBody === \"string\") {\n                    // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n                    //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n                    instance[key] = responseBody;\n                }\n            }\n            else {\n                const propertyName = xmlElementName || xmlName || serializedName;\n                if (propertyMapper.xmlIsWrapped) {\n                    /* a list of <xmlElementName> wrapped by <xmlName>\n                      For the xml example below\n                        <Cors>\n                          <CorsRule>...</CorsRule>\n                          <CorsRule>...</CorsRule>\n                        </Cors>\n                      the responseBody has\n                        {\n                          Cors: {\n                            CorsRule: [{...}, {...}]\n                          }\n                        }\n                      xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n                    */\n                    const wrapped = responseBody[xmlName];\n                    const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];\n                    instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);\n                    handledPropertyNames.push(xmlName);\n                }\n                else {\n                    const property = responseBody[propertyName];\n                    instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);\n                    handledPropertyNames.push(propertyName);\n                }\n            }\n        }\n        else {\n            // deserialize the property if it is present in the provided responseBody instance\n            let propertyInstance;\n            let res = responseBody;\n            // traversing the object step by step.\n            let steps = 0;\n            for (const item of paths) {\n                if (!res)\n                    break;\n                steps++;\n                res = res[item];\n            }\n            // only accept null when reaching the last position of object otherwise it would be undefined\n            if (res === null && steps < paths.length) {\n                res = undefined;\n            }\n            propertyInstance = res;\n            const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n            // checking that the model property name (key)(ex: \"fishtype\") and the\n            // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n            // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n            // is a better approach. The generator is not consistent with escaping '\\.' in the\n            // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n            // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n            // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n            // the transformation of model property name (ex: \"fishtype\") is done consistently.\n            // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n            if (polymorphicDiscriminator &&\n                key === polymorphicDiscriminator.clientName &&\n                (propertyInstance === undefined || propertyInstance === null)) {\n                propertyInstance = mapper.serializedName;\n            }\n            let serializedValue;\n            // paging\n            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n                propertyInstance = responseBody[key];\n                const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n                // Copy over any properties that have already been added into the instance, where they do\n                // not exist on the newly de-serialized array\n                for (const [k, v] of Object.entries(instance)) {\n                    if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n                        arrayInstance[k] = v;\n                    }\n                }\n                instance = arrayInstance;\n            }\n            else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n                instance[key] = serializedValue;\n            }\n        }\n    }\n    const additionalPropertiesMapper = mapper.type.additionalProperties;\n    if (additionalPropertiesMapper) {\n        const isAdditionalProperty = (responsePropName) => {\n            for (const clientPropName in modelProps) {\n                const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n                if (paths[0] === responsePropName) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        for (const responsePropName in responseBody) {\n            if (isAdditionalProperty(responsePropName)) {\n                instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]', options);\n            }\n        }\n    }\n    else if (responseBody && !options.ignoreUnknownProperties) {\n        for (const key of Object.keys(responseBody)) {\n            if (instance[key] === undefined &&\n                !handledPropertyNames.includes(key) &&\n                !isSpecialXmlProperty(key, options)) {\n                instance[key] = responseBody[key];\n            }\n        }\n    }\n    return instance;\n}\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {\n    /* jshint validthis: true */\n    const value = mapper.type.value;\n    if (!value || typeof value !== \"object\") {\n        throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}`);\n    }\n    if (responseBody) {\n        const tempDictionary = {};\n        for (const key of Object.keys(responseBody)) {\n            tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n        }\n        return tempDictionary;\n    }\n    return responseBody;\n}\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {\n    var _a;\n    let element = mapper.type.element;\n    if (!element || typeof element !== \"object\") {\n        throw new Error(`element\" metadata for an Array must be defined in the ` +\n            `mapper and it must of type \"object\" in ${objectName}`);\n    }\n    if (responseBody) {\n        if (!Array.isArray(responseBody)) {\n            // xml2js will interpret a single element array as just the element, so force it to be an array\n            responseBody = [responseBody];\n        }\n        // Quirk: Composite mappers referenced by `element` might\n        // not have *all* properties declared (like uberParent),\n        // so let's try to look up the full definition by name.\n        if (element.type.name === \"Composite\" && element.type.className) {\n            element = (_a = serializer.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;\n        }\n        const tempArray = [];\n        for (let i = 0; i < responseBody.length; i++) {\n            tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);\n        }\n        return tempArray;\n    }\n    return responseBody;\n}\nfunction getIndexDiscriminator(discriminators, discriminatorValue, typeName) {\n    const typeNamesToCheck = [typeName];\n    while (typeNamesToCheck.length) {\n        const currentName = typeNamesToCheck.shift();\n        const indexDiscriminator = discriminatorValue === currentName\n            ? discriminatorValue\n            : currentName + \".\" + discriminatorValue;\n        if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {\n            return discriminators[indexDiscriminator];\n        }\n        else {\n            for (const [name, mapper] of Object.entries(discriminators)) {\n                if (name.startsWith(currentName + \".\") &&\n                    mapper.type.uberParent === currentName &&\n                    mapper.type.className) {\n                    typeNamesToCheck.push(mapper.type.className);\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n    var _a;\n    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n    if (polymorphicDiscriminator) {\n        let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n        if (discriminatorName) {\n            // The serializedName might have \\\\, which we just want to ignore\n            if (polymorphicPropertyName === \"serializedName\") {\n                discriminatorName = discriminatorName.replace(/\\\\/gi, \"\");\n            }\n            const discriminatorValue = object[discriminatorName];\n            const typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;\n            if (typeof discriminatorValue === \"string\" && typeName) {\n                const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);\n                if (polymorphicMapper) {\n                    mapper = polymorphicMapper;\n                }\n            }\n        }\n    }\n    return mapper;\n}\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n    return (mapper.type.polymorphicDiscriminator ||\n        getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n        getPolymorphicDiscriminatorSafely(serializer, mapper.type.className));\n}\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n    return (typeName &&\n        serializer.modelMappers[typeName] &&\n        serializer.modelMappers[typeName].type.polymorphicDiscriminator);\n}\n/**\n * Known types of Mappers\n */\nexport const MapperTypeNames = {\n    Base64Url: \"Base64Url\",\n    Boolean: \"Boolean\",\n    ByteArray: \"ByteArray\",\n    Composite: \"Composite\",\n    Date: \"Date\",\n    DateTime: \"DateTime\",\n    DateTimeRfc1123: \"DateTimeRfc1123\",\n    Dictionary: \"Dictionary\",\n    Enum: \"Enum\",\n    Number: \"Number\",\n    Object: \"Object\",\n    Sequence: \"Sequence\",\n    String: \"String\",\n    Stream: \"Stream\",\n    TimeSpan: \"TimeSpan\",\n    UnixTime: \"UnixTime\",\n};\n//# sourceMappingURL=serializer.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Default key used to access the XML attributes.\n */\nexport const XML_ATTRKEY = \"$\";\n/**\n * Default key used to access the XML value content.\n */\nexport const XML_CHARKEY = \"_\";\n//# sourceMappingURL=interfaces.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Browser-only implementation of the module's state. The browser esm variant will not load the commonjs state, so we do not need to share state between the two.\n */\nexport const state = {\n    operationRequestMap: new WeakMap(),\n};\n//# sourceMappingURL=state-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { state } from \"./state.js\";\n/**\n * @internal\n * Retrieves the value to use for a given operation argument\n * @param operationArguments - The arguments passed from the generated client\n * @param parameter - The parameter description\n * @param fallbackObject - If something isn't found in the arguments bag, look here.\n *  Generally used to look at the service client properties.\n */\nexport function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {\n    let parameterPath = parameter.parameterPath;\n    const parameterMapper = parameter.mapper;\n    let value;\n    if (typeof parameterPath === \"string\") {\n        parameterPath = [parameterPath];\n    }\n    if (Array.isArray(parameterPath)) {\n        if (parameterPath.length > 0) {\n            if (parameterMapper.isConstant) {\n                value = parameterMapper.defaultValue;\n            }\n            else {\n                let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n                if (!propertySearchResult.propertyFound && fallbackObject) {\n                    propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);\n                }\n                let useDefaultValue = false;\n                if (!propertySearchResult.propertyFound) {\n                    useDefaultValue =\n                        parameterMapper.required ||\n                            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n                }\n                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n            }\n        }\n    }\n    else {\n        if (parameterMapper.required) {\n            value = {};\n        }\n        for (const propertyName in parameterPath) {\n            const propertyMapper = parameterMapper.type.modelProperties[propertyName];\n            const propertyPath = parameterPath[propertyName];\n            const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {\n                parameterPath: propertyPath,\n                mapper: propertyMapper,\n            }, fallbackObject);\n            if (propertyValue !== undefined) {\n                if (!value) {\n                    value = {};\n                }\n                value[propertyName] = propertyValue;\n            }\n        }\n    }\n    return value;\n}\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n    const result = { propertyFound: false };\n    let i = 0;\n    for (; i < parameterPath.length; ++i) {\n        const parameterPathPart = parameterPath[i];\n        // Make sure to check inherited properties too, so don't use hasOwnProperty().\n        if (parent && parameterPathPart in parent) {\n            parent = parent[parameterPathPart];\n        }\n        else {\n            break;\n        }\n    }\n    if (i === parameterPath.length) {\n        result.propertyValue = parent;\n        result.propertyFound = true;\n    }\n    return result;\n}\nconst originalRequestSymbol = Symbol.for(\"@azure/core-client original request\");\nfunction hasOriginalRequest(request) {\n    return originalRequestSymbol in request;\n}\nexport function getOperationRequestInfo(request) {\n    if (hasOriginalRequest(request)) {\n        return getOperationRequestInfo(request[originalRequestSymbol]);\n    }\n    let info = state.operationRequestMap.get(request);\n    if (!info) {\n        info = {};\n        state.operationRequestMap.set(request, info);\n    }\n    return info;\n}\n//# sourceMappingURL=operationHelpers.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_CHARKEY } from \"./interfaces.js\";\nimport { RestError } from \"@azure/core-rest-pipeline\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nconst defaultJsonContentTypes = [\"application/json\", \"text/json\"];\nconst defaultXmlContentTypes = [\"application/xml\", \"application/atom+xml\"];\n/**\n * The programmatic identifier of the deserializationPolicy.\n */\nexport const deserializationPolicyName = \"deserializationPolicy\";\n/**\n * This policy handles parsing out responses according to OperationSpecs on the request.\n */\nexport function deserializationPolicy(options = {}) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;\n    const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;\n    const parseXML = options.parseXML;\n    const serializerOptions = options.serializerOptions;\n    const updatedOptions = {\n        xml: {\n            rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : \"\",\n            includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,\n            xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY,\n        },\n    };\n    return {\n        name: deserializationPolicyName,\n        async sendRequest(request, next) {\n            const response = await next(request);\n            return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);\n        },\n    };\n}\nfunction getOperationResponseMap(parsedResponse) {\n    let result;\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (operationSpec) {\n        if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {\n            result = operationSpec.responses[parsedResponse.status];\n        }\n        else {\n            result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);\n        }\n    }\n    return result;\n}\nfunction shouldDeserializeResponse(parsedResponse) {\n    const request = parsedResponse.request;\n    const operationInfo = getOperationRequestInfo(request);\n    const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;\n    let result;\n    if (shouldDeserialize === undefined) {\n        result = true;\n    }\n    else if (typeof shouldDeserialize === \"boolean\") {\n        result = shouldDeserialize;\n    }\n    else {\n        result = shouldDeserialize(parsedResponse);\n    }\n    return result;\n}\nasync function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {\n    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);\n    if (!shouldDeserializeResponse(parsedResponse)) {\n        return parsedResponse;\n    }\n    const operationInfo = getOperationRequestInfo(parsedResponse.request);\n    const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n    if (!operationSpec || !operationSpec.responses) {\n        return parsedResponse;\n    }\n    const responseSpec = getOperationResponseMap(parsedResponse);\n    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);\n    if (error) {\n        throw error;\n    }\n    else if (shouldReturnResponse) {\n        return parsedResponse;\n    }\n    // An operation response spec does exist for current status code, so\n    // use it to deserialize the response.\n    if (responseSpec) {\n        if (responseSpec.bodyMapper) {\n            let valueToDeserialize = parsedResponse.parsedBody;\n            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {\n                valueToDeserialize =\n                    typeof valueToDeserialize === \"object\"\n                        ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]\n                        : [];\n            }\n            try {\n                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, \"operationRes.parsedBody\", options);\n            }\n            catch (deserializeError) {\n                const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {\n                    statusCode: parsedResponse.status,\n                    request: parsedResponse.request,\n                    response: parsedResponse,\n                });\n                throw restError;\n            }\n        }\n        else if (operationSpec.httpMethod === \"HEAD\") {\n            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource\n            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;\n        }\n        if (responseSpec.headersMapper) {\n            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\", { xml: {}, ignoreUnknownProperties: true });\n        }\n    }\n    return parsedResponse;\n}\nfunction isOperationSpecEmpty(operationSpec) {\n    const expectedStatusCodes = Object.keys(operationSpec.responses);\n    return (expectedStatusCodes.length === 0 ||\n        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === \"default\"));\n}\nfunction handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {\n    var _a, _b, _c, _d, _e;\n    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;\n    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)\n        ? isSuccessByStatus\n        : !!responseSpec;\n    if (isExpectedStatusCode) {\n        if (responseSpec) {\n            if (!responseSpec.isError) {\n                return { error: null, shouldReturnResponse: false };\n            }\n        }\n        else {\n            return { error: null, shouldReturnResponse: false };\n        }\n    }\n    const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;\n    const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status))\n        ? `Unexpected status code: ${parsedResponse.status}`\n        : parsedResponse.bodyAsText;\n    const error = new RestError(initialErrorMessage, {\n        statusCode: parsedResponse.status,\n        request: parsedResponse.request,\n        response: parsedResponse,\n    });\n    // If the item failed but there's no error spec or default spec to deserialize the error,\n    // and the parsed body doesn't look like an error object,\n    // we should fail so we just throw the parsed response\n    if (!errorResponseSpec &&\n        !(((_c = (_b = parsedResponse.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.code) && ((_e = (_d = parsedResponse.parsedBody) === null || _d === void 0 ? void 0 : _d.error) === null || _e === void 0 ? void 0 : _e.message))) {\n        throw error;\n    }\n    const defaultBodyMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.bodyMapper;\n    const defaultHeadersMapper = errorResponseSpec === null || errorResponseSpec === void 0 ? void 0 : errorResponseSpec.headersMapper;\n    try {\n        // If error response has a body, try to deserialize it using default body mapper.\n        // Then try to extract error code & message from it\n        if (parsedResponse.parsedBody) {\n            const parsedBody = parsedResponse.parsedBody;\n            let deserializedError;\n            if (defaultBodyMapper) {\n                let valueToDeserialize = parsedBody;\n                if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {\n                    valueToDeserialize = [];\n                    const elementName = defaultBodyMapper.xmlElementName;\n                    if (typeof parsedBody === \"object\" && elementName) {\n                        valueToDeserialize = parsedBody[elementName];\n                    }\n                }\n                deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, \"error.response.parsedBody\", options);\n            }\n            const internalError = parsedBody.error || deserializedError || parsedBody;\n            error.code = internalError.code;\n            if (internalError.message) {\n                error.message = internalError.message;\n            }\n            if (defaultBodyMapper) {\n                error.response.parsedBody = deserializedError;\n            }\n        }\n        // If error response has headers, try to deserialize it using default header mapper\n        if (parsedResponse.headers && defaultHeadersMapper) {\n            error.response.parsedHeaders =\n                operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), \"operationRes.parsedHeaders\");\n        }\n    }\n    catch (defaultError) {\n        error.message = `Error \"${defaultError.message}\" occurred in deserializing the responseBody - \"${parsedResponse.bodyAsText}\" for the default response.`;\n    }\n    return { error, shouldReturnResponse: false };\n}\nasync function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {\n    var _a;\n    if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) &&\n        operationResponse.bodyAsText) {\n        const text = operationResponse.bodyAsText;\n        const contentType = operationResponse.headers.get(\"Content-Type\") || \"\";\n        const contentComponents = !contentType\n            ? []\n            : contentType.split(\";\").map((component) => component.toLowerCase());\n        try {\n            if (contentComponents.length === 0 ||\n                contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {\n                operationResponse.parsedBody = JSON.parse(text);\n                return operationResponse;\n            }\n            else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {\n                if (!parseXML) {\n                    throw new Error(\"Parsing XML not supported.\");\n                }\n                const body = await parseXML(text, opts.xml);\n                operationResponse.parsedBody = body;\n                return operationResponse;\n            }\n        }\n        catch (err) {\n            const msg = `Error \"${err}\" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;\n            const errCode = err.code || RestError.PARSE_ERROR;\n            const e = new RestError(msg, {\n                code: errCode,\n                statusCode: operationResponse.status,\n                request: operationResponse.request,\n                response: operationResponse,\n            });\n            throw e;\n        }\n    }\n    return operationResponse;\n}\n//# sourceMappingURL=deserializationPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { MapperTypeNames } from \"./serializer.js\";\n/**\n * Gets the list of status codes for streaming responses.\n * @internal\n */\nexport function getStreamingResponseStatusCodes(operationSpec) {\n    const result = new Set();\n    for (const statusCode in operationSpec.responses) {\n        const operationResponse = operationSpec.responses[statusCode];\n        if (operationResponse.bodyMapper &&\n            operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {\n            result.add(Number(statusCode));\n        }\n    }\n    return result;\n}\n/**\n * Get the path to this parameter's value as a dotted string (a.b.c).\n * @param parameter - The parameter to get the path string for.\n * @returns The path to this parameter's value as a dotted string.\n * @internal\n */\nexport function getPathStringFromParameter(parameter) {\n    const { parameterPath, mapper } = parameter;\n    let result;\n    if (typeof parameterPath === \"string\") {\n        result = parameterPath;\n    }\n    else if (Array.isArray(parameterPath)) {\n        result = parameterPath.join(\".\");\n    }\n    else {\n        result = mapper.serializedName;\n    }\n    return result;\n}\n//# sourceMappingURL=interfaceHelpers.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./interfaces.js\";\nimport { getOperationArgumentValueFromParameter, getOperationRequestInfo, } from \"./operationHelpers.js\";\nimport { MapperTypeNames } from \"./serializer.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\n/**\n * The programmatic identifier of the serializationPolicy.\n */\nexport const serializationPolicyName = \"serializationPolicy\";\n/**\n * This policy handles assembling the request body and headers using\n * an OperationSpec and OperationArguments on the request.\n */\nexport function serializationPolicy(options = {}) {\n    const stringifyXML = options.stringifyXML;\n    return {\n        name: serializationPolicyName,\n        async sendRequest(request, next) {\n            const operationInfo = getOperationRequestInfo(request);\n            const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;\n            const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;\n            if (operationSpec && operationArguments) {\n                serializeHeaders(request, operationArguments, operationSpec);\n                serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);\n            }\n            return next(request);\n        },\n    };\n}\n/**\n * @internal\n */\nexport function serializeHeaders(request, operationArguments, operationSpec) {\n    var _a, _b;\n    if (operationSpec.headerParameters) {\n        for (const headerParameter of operationSpec.headerParameters) {\n            let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);\n            if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {\n                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));\n                const headerCollectionPrefix = headerParameter.mapper\n                    .headerCollectionPrefix;\n                if (headerCollectionPrefix) {\n                    for (const key of Object.keys(headerValue)) {\n                        request.headers.set(headerCollectionPrefix + key, headerValue[key]);\n                    }\n                }\n                else {\n                    request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);\n                }\n            }\n        }\n    }\n    const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;\n    if (customHeaders) {\n        for (const customHeaderName of Object.keys(customHeaders)) {\n            request.headers.set(customHeaderName, customHeaders[customHeaderName]);\n        }\n    }\n}\n/**\n * @internal\n */\nexport function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {\n    throw new Error(\"XML serialization unsupported!\");\n}) {\n    var _a, _b, _c, _d, _e;\n    const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;\n    const updatedOptions = {\n        xml: {\n            rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : \"\",\n            includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,\n            xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY,\n        },\n    };\n    const xmlCharKey = updatedOptions.xml.xmlCharKey;\n    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {\n        request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);\n        const bodyMapper = operationSpec.requestBody.mapper;\n        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable, } = bodyMapper;\n        const typeName = bodyMapper.type.name;\n        try {\n            if ((request.body !== undefined && request.body !== null) ||\n                (nullable && request.body === null) ||\n                required) {\n                const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);\n                request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);\n                const isStream = typeName === MapperTypeNames.Stream;\n                if (operationSpec.isXML) {\n                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : \"xmlns\";\n                    const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);\n                    if (typeName === MapperTypeNames.Sequence) {\n                        request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });\n                    }\n                    else if (!isStream) {\n                        request.body = stringifyXML(value, {\n                            rootName: xmlName || serializedName,\n                            xmlCharKey,\n                        });\n                    }\n                }\n                else if (typeName === MapperTypeNames.String &&\n                    (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match(\"text/plain\")) || operationSpec.mediaType === \"text\")) {\n                    // the String serializer has validated that request body is a string\n                    // so just send the string.\n                    return;\n                }\n                else if (!isStream) {\n                    request.body = JSON.stringify(request.body);\n                }\n            }\n        }\n        catch (error) {\n            throw new Error(`Error \"${error.message}\" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, \"  \")}.`);\n        }\n    }\n    else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {\n        request.formData = {};\n        for (const formDataParameter of operationSpec.formDataParameters) {\n            const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);\n            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {\n                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);\n                request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);\n            }\n        }\n    }\n}\n/**\n * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself\n */\nfunction getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {\n    // Composite and Sequence schemas already got their root namespace set during serialization\n    // We just need to add xmlns to the other schema types\n    if (xmlNamespace && ![\"Composite\", \"Sequence\", \"Dictionary\"].includes(typeName)) {\n        const result = {};\n        result[options.xml.xmlCharKey] = serializedValue;\n        result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };\n        return result;\n    }\n    return serializedValue;\n}\nfunction prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {\n    if (!Array.isArray(obj)) {\n        obj = [obj];\n    }\n    if (!xmlNamespaceKey || !xmlNamespace) {\n        return { [elementName]: obj };\n    }\n    const result = { [elementName]: obj };\n    result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };\n    return result;\n}\n//# sourceMappingURL=serializationPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { deserializationPolicy } from \"./deserializationPolicy.js\";\nimport { bearerTokenAuthenticationPolicy, createPipelineFromOptions, } from \"@azure/core-rest-pipeline\";\nimport { serializationPolicy } from \"./serializationPolicy.js\";\n/**\n * Creates a new Pipeline for use with a Service Client.\n * Adds in deserializationPolicy by default.\n * Also adds in bearerTokenAuthenticationPolicy if passed a TokenCredential.\n * @param options - Options to customize the created pipeline.\n */\nexport function createClientPipeline(options = {}) {\n    const pipeline = createPipelineFromOptions(options !== null && options !== void 0 ? options : {});\n    if (options.credentialOptions) {\n        pipeline.addPolicy(bearerTokenAuthenticationPolicy({\n            credential: options.credentialOptions.credential,\n            scopes: options.credentialOptions.credentialScopes,\n        }));\n    }\n    pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: \"Serialize\" });\n    pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {\n        phase: \"Deserialize\",\n    });\n    return pipeline;\n}\n//# sourceMappingURL=pipeline.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * A type guard for a primitive response body.\n * @param value - Value to test\n *\n * @internal\n */\nexport function isPrimitiveBody(value, mapperTypeName) {\n    return (mapperTypeName !== \"Composite\" &&\n        mapperTypeName !== \"Dictionary\" &&\n        (typeof value === \"string\" ||\n            typeof value === \"number\" ||\n            typeof value === \"boolean\" ||\n            (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !==\n                null ||\n            value === undefined ||\n            value === null));\n}\nconst validateISODuration = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n/**\n * Returns true if the given string is in ISO 8601 format.\n * @param value - The value to be validated for ISO 8601 duration format.\n * @internal\n */\nexport function isDuration(value) {\n    return validateISODuration.test(value);\n}\nconst validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;\n/**\n * Returns true if the provided uuid is valid.\n *\n * @param uuid - The uuid that needs to be validated.\n *\n * @internal\n */\nexport function isValidUuid(uuid) {\n    return validUuidRegex.test(uuid);\n}\n/**\n * Maps the response as follows:\n * - wraps the response body if needed (typically if its type is primitive).\n * - returns null if the combination of the headers and the body is empty.\n * - otherwise, returns the combination of the headers and the body.\n *\n * @param responseObject - a representation of the parsed response\n * @returns the response that will be returned to the user which can be null and/or wrapped\n *\n * @internal\n */\nfunction handleNullableResponseAndWrappableBody(responseObject) {\n    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);\n    if (responseObject.hasNullableType &&\n        Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {\n        return responseObject.shouldWrapBody ? { body: null } : null;\n    }\n    else {\n        return responseObject.shouldWrapBody\n            ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;\n    }\n}\n/**\n * Take a `FullOperationResponse` and turn it into a flat\n * response object to hand back to the consumer.\n * @param fullResponse - The processed response from the operation request\n * @param responseSpec - The response map from the OperationSpec\n *\n * @internal\n */\nexport function flattenResponse(fullResponse, responseSpec) {\n    var _a, _b;\n    const parsedHeaders = fullResponse.parsedHeaders;\n    // head methods never have a body, but we return a boolean set to body property\n    // to indicate presence/absence of the resource\n    if (fullResponse.request.method === \"HEAD\") {\n        return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });\n    }\n    const bodyMapper = responseSpec && responseSpec.bodyMapper;\n    const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);\n    const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;\n    /** If the body is asked for, we look at the expected body type to handle it */\n    if (expectedBodyTypeName === \"Stream\") {\n        return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });\n    }\n    const modelProperties = (expectedBodyTypeName === \"Composite\" &&\n        bodyMapper.type.modelProperties) ||\n        {};\n    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === \"\");\n    if (expectedBodyTypeName === \"Sequence\" || isPageableResponse) {\n        const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];\n        for (const key of Object.keys(modelProperties)) {\n            if (modelProperties[key].serializedName) {\n                arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];\n            }\n        }\n        if (parsedHeaders) {\n            for (const key of Object.keys(parsedHeaders)) {\n                arrayResponse[key] = parsedHeaders[key];\n            }\n        }\n        return isNullable &&\n            !fullResponse.parsedBody &&\n            !parsedHeaders &&\n            Object.getOwnPropertyNames(modelProperties).length === 0\n            ? null\n            : arrayResponse;\n    }\n    return handleNullableResponseAndWrappableBody({\n        body: fullResponse.parsedBody,\n        headers: parsedHeaders,\n        hasNullableType: isNullable,\n        shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),\n    });\n}\n//# sourceMappingURL=utils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createDefaultHttpClient } from \"@azure/core-rest-pipeline\";\nlet cachedHttpClient;\nexport function getCachedDefaultHttpClient() {\n    if (!cachedHttpClient) {\n        cachedHttpClient = createDefaultHttpClient();\n    }\n    return cachedHttpClient;\n}\n//# sourceMappingURL=httpClientCache.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getOperationArgumentValueFromParameter } from \"./operationHelpers.js\";\nimport { getPathStringFromParameter } from \"./interfaceHelpers.js\";\nconst CollectionFormatToDelimiterMap = {\n    CSV: \",\",\n    SSV: \" \",\n    Multi: \"Multi\",\n    TSV: \"\\t\",\n    Pipes: \"|\",\n};\nexport function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {\n    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);\n    let isAbsolutePath = false;\n    let requestUrl = replaceAll(baseUri, urlReplacements);\n    if (operationSpec.path) {\n        let path = replaceAll(operationSpec.path, urlReplacements);\n        // QUIRK: sometimes we get a path component like /{nextLink}\n        // which may be a fully formed URL with a leading /. In that case, we should\n        // remove the leading /\n        if (operationSpec.path === \"/{nextLink}\" && path.startsWith(\"/\")) {\n            path = path.substring(1);\n        }\n        // QUIRK: sometimes we get a path component like {nextLink}\n        // which may be a fully formed URL. In that case, we should\n        // ignore the baseUri.\n        if (isAbsoluteUrl(path)) {\n            requestUrl = path;\n            isAbsolutePath = true;\n        }\n        else {\n            requestUrl = appendPath(requestUrl, path);\n        }\n    }\n    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);\n    /**\n     * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`\n     * is an absolute path. This ensures that existing query parameter values in `requestUrl`\n     * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it\n     * is still being built so there is nothing to overwrite.\n     */\n    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);\n    return requestUrl;\n}\nfunction replaceAll(input, replacements) {\n    let result = input;\n    for (const [searchValue, replaceValue] of replacements) {\n        result = result.split(searchValue).join(replaceValue);\n    }\n    return result;\n}\nfunction calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {\n    var _a;\n    const result = new Map();\n    if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {\n        for (const urlParameter of operationSpec.urlParameters) {\n            let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);\n            const parameterPathString = getPathStringFromParameter(urlParameter);\n            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);\n            if (!urlParameter.skipEncoding) {\n                urlParameterValue = encodeURIComponent(urlParameterValue);\n            }\n            result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);\n        }\n    }\n    return result;\n}\nfunction isAbsoluteUrl(url) {\n    return url.includes(\"://\");\n}\nfunction appendPath(url, pathToAppend) {\n    if (!pathToAppend) {\n        return url;\n    }\n    const parsedUrl = new URL(url);\n    let newPath = parsedUrl.pathname;\n    if (!newPath.endsWith(\"/\")) {\n        newPath = `${newPath}/`;\n    }\n    if (pathToAppend.startsWith(\"/\")) {\n        pathToAppend = pathToAppend.substring(1);\n    }\n    const searchStart = pathToAppend.indexOf(\"?\");\n    if (searchStart !== -1) {\n        const path = pathToAppend.substring(0, searchStart);\n        const search = pathToAppend.substring(searchStart + 1);\n        newPath = newPath + path;\n        if (search) {\n            parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;\n        }\n    }\n    else {\n        newPath = newPath + pathToAppend;\n    }\n    parsedUrl.pathname = newPath;\n    return parsedUrl.toString();\n}\nfunction calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {\n    var _a;\n    const result = new Map();\n    const sequenceParams = new Set();\n    if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {\n        for (const queryParameter of operationSpec.queryParameters) {\n            if (queryParameter.mapper.type.name === \"Sequence\" && queryParameter.mapper.serializedName) {\n                sequenceParams.add(queryParameter.mapper.serializedName);\n            }\n            let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);\n            if ((queryParameterValue !== undefined && queryParameterValue !== null) ||\n                queryParameter.mapper.required) {\n                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));\n                const delimiter = queryParameter.collectionFormat\n                    ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]\n                    : \"\";\n                if (Array.isArray(queryParameterValue)) {\n                    // replace null and undefined\n                    queryParameterValue = queryParameterValue.map((item) => {\n                        if (item === null || item === undefined) {\n                            return \"\";\n                        }\n                        return item;\n                    });\n                }\n                if (queryParameter.collectionFormat === \"Multi\" && queryParameterValue.length === 0) {\n                    continue;\n                }\n                else if (Array.isArray(queryParameterValue) &&\n                    (queryParameter.collectionFormat === \"SSV\" || queryParameter.collectionFormat === \"TSV\")) {\n                    queryParameterValue = queryParameterValue.join(delimiter);\n                }\n                if (!queryParameter.skipEncoding) {\n                    if (Array.isArray(queryParameterValue)) {\n                        queryParameterValue = queryParameterValue.map((item) => {\n                            return encodeURIComponent(item);\n                        });\n                    }\n                    else {\n                        queryParameterValue = encodeURIComponent(queryParameterValue);\n                    }\n                }\n                // Join pipes and CSV *after* encoding, or the server will be upset.\n                if (Array.isArray(queryParameterValue) &&\n                    (queryParameter.collectionFormat === \"CSV\" || queryParameter.collectionFormat === \"Pipes\")) {\n                    queryParameterValue = queryParameterValue.join(delimiter);\n                }\n                result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);\n            }\n        }\n    }\n    return {\n        queryParams: result,\n        sequenceParams,\n    };\n}\nfunction simpleParseQueryParams(queryString) {\n    const result = new Map();\n    if (!queryString || queryString[0] !== \"?\") {\n        return result;\n    }\n    // remove the leading ?\n    queryString = queryString.slice(1);\n    const pairs = queryString.split(\"&\");\n    for (const pair of pairs) {\n        const [name, value] = pair.split(\"=\", 2);\n        const existingValue = result.get(name);\n        if (existingValue) {\n            if (Array.isArray(existingValue)) {\n                existingValue.push(value);\n            }\n            else {\n                result.set(name, [existingValue, value]);\n            }\n        }\n        else {\n            result.set(name, value);\n        }\n    }\n    return result;\n}\n/** @internal */\nexport function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {\n    if (queryParams.size === 0) {\n        return url;\n    }\n    const parsedUrl = new URL(url);\n    // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which\n    // can change their meaning to the server, such as in the case of a SAS signature.\n    // To avoid accidentally un-encoding a query param, we parse the key/values ourselves\n    const combinedParams = simpleParseQueryParams(parsedUrl.search);\n    for (const [name, value] of queryParams) {\n        const existingValue = combinedParams.get(name);\n        if (Array.isArray(existingValue)) {\n            if (Array.isArray(value)) {\n                existingValue.push(...value);\n                const valueSet = new Set(existingValue);\n                combinedParams.set(name, Array.from(valueSet));\n            }\n            else {\n                existingValue.push(value);\n            }\n        }\n        else if (existingValue) {\n            if (Array.isArray(value)) {\n                value.unshift(existingValue);\n            }\n            else if (sequenceParams.has(name)) {\n                combinedParams.set(name, [existingValue, value]);\n            }\n            if (!noOverwrite) {\n                combinedParams.set(name, value);\n            }\n        }\n        else {\n            combinedParams.set(name, value);\n        }\n    }\n    const searchPieces = [];\n    for (const [name, value] of combinedParams) {\n        if (typeof value === \"string\") {\n            searchPieces.push(`${name}=${value}`);\n        }\n        else if (Array.isArray(value)) {\n            // QUIRK: If we get an array of values, include multiple key/value pairs\n            for (const subValue of value) {\n                searchPieces.push(`${name}=${subValue}`);\n            }\n        }\n        else {\n            searchPieces.push(`${name}=${value}`);\n        }\n    }\n    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.\n    parsedUrl.search = searchPieces.length ? `?${searchPieces.join(\"&\")}` : \"\";\n    return parsedUrl.toString();\n}\n//# sourceMappingURL=urlHelpers.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-client\");\n//# sourceMappingURL=log.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { createClientPipeline } from \"./pipeline.js\";\nimport { flattenResponse } from \"./utils.js\";\nimport { getCachedDefaultHttpClient } from \"./httpClientCache.js\";\nimport { getOperationRequestInfo } from \"./operationHelpers.js\";\nimport { getRequestUrl } from \"./urlHelpers.js\";\nimport { getStreamingResponseStatusCodes } from \"./interfaceHelpers.js\";\nimport { logger } from \"./log.js\";\n/**\n * Initializes a new instance of the ServiceClient.\n */\nexport class ServiceClient {\n    /**\n     * The ServiceClient constructor\n     * @param options - The service client options that govern the behavior of the client.\n     */\n    constructor(options = {}) {\n        var _a, _b;\n        this._requestContentType = options.requestContentType;\n        this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;\n        if (options.baseUri) {\n            logger.warning(\"The baseUri option for SDK Clients has been deprecated, please use endpoint instead.\");\n        }\n        this._allowInsecureConnection = options.allowInsecureConnection;\n        this._httpClient = options.httpClient || getCachedDefaultHttpClient();\n        this.pipeline = options.pipeline || createDefaultPipeline(options);\n        if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {\n            for (const { policy, position } of options.additionalPolicies) {\n                // Sign happens after Retry and is commonly needed to occur\n                // before policies that intercept post-retry.\n                const afterPhase = position === \"perRetry\" ? \"Sign\" : undefined;\n                this.pipeline.addPolicy(policy, {\n                    afterPhase,\n                });\n            }\n        }\n    }\n    /**\n     * Send the provided httpRequest.\n     */\n    async sendRequest(request) {\n        return this.pipeline.sendRequest(this._httpClient, request);\n    }\n    /**\n     * Send an HTTP request that is populated using the provided OperationSpec.\n     * @typeParam T - The typed result of the request, based on the OperationSpec.\n     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.\n     * @param operationSpec - The OperationSpec to use to populate the httpRequest.\n     */\n    async sendOperationRequest(operationArguments, operationSpec) {\n        const endpoint = operationSpec.baseUrl || this._endpoint;\n        if (!endpoint) {\n            throw new Error(\"If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.\");\n        }\n        // Templatized URLs sometimes reference properties on the ServiceClient child class,\n        // so we have to pass `this` below in order to search these properties if they're\n        // not part of OperationArguments\n        const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);\n        const request = createPipelineRequest({\n            url,\n        });\n        request.method = operationSpec.httpMethod;\n        const operationInfo = getOperationRequestInfo(request);\n        operationInfo.operationSpec = operationSpec;\n        operationInfo.operationArguments = operationArguments;\n        const contentType = operationSpec.contentType || this._requestContentType;\n        if (contentType && operationSpec.requestBody) {\n            request.headers.set(\"Content-Type\", contentType);\n        }\n        const options = operationArguments.options;\n        if (options) {\n            const requestOptions = options.requestOptions;\n            if (requestOptions) {\n                if (requestOptions.timeout) {\n                    request.timeout = requestOptions.timeout;\n                }\n                if (requestOptions.onUploadProgress) {\n                    request.onUploadProgress = requestOptions.onUploadProgress;\n                }\n                if (requestOptions.onDownloadProgress) {\n                    request.onDownloadProgress = requestOptions.onDownloadProgress;\n                }\n                if (requestOptions.shouldDeserialize !== undefined) {\n                    operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;\n                }\n                if (requestOptions.allowInsecureConnection) {\n                    request.allowInsecureConnection = true;\n                }\n            }\n            if (options.abortSignal) {\n                request.abortSignal = options.abortSignal;\n            }\n            if (options.tracingOptions) {\n                request.tracingOptions = options.tracingOptions;\n            }\n        }\n        if (this._allowInsecureConnection) {\n            request.allowInsecureConnection = true;\n        }\n        if (request.streamResponseStatusCodes === undefined) {\n            request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);\n        }\n        try {\n            const rawResponse = await this.sendRequest(request);\n            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);\n            if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                options.onResponse(rawResponse, flatResponse);\n            }\n            return flatResponse;\n        }\n        catch (error) {\n            if (typeof error === \"object\" && (error === null || error === void 0 ? void 0 : error.response)) {\n                const rawResponse = error.response;\n                const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses[\"default\"]);\n                error.details = flatResponse;\n                if (options === null || options === void 0 ? void 0 : options.onResponse) {\n                    options.onResponse(rawResponse, flatResponse, error);\n                }\n            }\n            throw error;\n        }\n    }\n}\nfunction createDefaultPipeline(options) {\n    const credentialScopes = getCredentialScopes(options);\n    const credentialOptions = options.credential && credentialScopes\n        ? { credentialScopes, credential: options.credential }\n        : undefined;\n    return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));\n}\nfunction getCredentialScopes(options) {\n    if (options.credentialScopes) {\n        return options.credentialScopes;\n    }\n    if (options.endpoint) {\n        return `${options.endpoint}/.default`;\n    }\n    if (options.baseUri) {\n        return `${options.baseUri}/.default`;\n    }\n    if (options.credential && !options.credentialScopes) {\n        throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);\n    }\n    return undefined;\n}\n//# sourceMappingURL=serviceClient.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { logger as coreClientLogger } from \"./log.js\";\nimport { decodeStringToString } from \"./base64.js\";\n/**\n * Converts: `Bearer a=\"b\", c=\"d\", Bearer d=\"e\", f=\"g\"`.\n * Into: `[ { a: 'b', c: 'd' }, { d: 'e', f: 'g' } ]`.\n *\n * @internal\n */\nexport function parseCAEChallenge(challenges) {\n    const bearerChallenges = `, ${challenges.trim()}`.split(\", Bearer \").filter((x) => x);\n    return bearerChallenges.map((challenge) => {\n        const challengeParts = `${challenge.trim()}, `.split('\", ').filter((x) => x);\n        const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('=\"')));\n        // Key-value pairs to plain object:\n        return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});\n    });\n}\n/**\n * This function can be used as a callback for the `bearerTokenAuthenticationPolicy` of `@azure/core-rest-pipeline`, to support CAE challenges:\n * [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation).\n *\n * Call the `bearerTokenAuthenticationPolicy` with the following options:\n *\n * ```ts snippet:AuthorizeRequestOnClaimChallenge\n * import { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\n * import { authorizeRequestOnClaimChallenge } from \"@azure/core-client\";\n *\n * const policy = bearerTokenAuthenticationPolicy({\n *   challengeCallbacks: {\n *     authorizeRequestOnChallenge: authorizeRequestOnClaimChallenge,\n *   },\n *   scopes: [\"https://service/.default\"],\n * });\n * ```\n *\n * Once provided, the `bearerTokenAuthenticationPolicy` policy will internally handle Continuous Access Evaluation (CAE) challenges.\n * When it can't complete a challenge it will return the 401 (unauthorized) response from ARM.\n *\n * Example challenge with claims:\n *\n * ```\n * Bearer authorization_uri=\"https://login.windows-ppe.net/\", error=\"invalid_token\",\n * error_description=\"User session has been revoked\",\n * claims=\"eyJhY2Nlc3NfdG9rZW4iOnsibmJmIjp7ImVzc2VudGlhbCI6dHJ1ZSwgInZhbHVlIjoiMTYwMzc0MjgwMCJ9fX0=\"\n * ```\n */\nexport async function authorizeRequestOnClaimChallenge(onChallengeOptions) {\n    var _a;\n    const { scopes, response } = onChallengeOptions;\n    const logger = onChallengeOptions.logger || coreClientLogger;\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (!challenge) {\n        logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);\n        return false;\n    }\n    const challenges = parseCAEChallenge(challenge) || [];\n    const parsedChallenge = challenges.find((x) => x.claims);\n    if (!parsedChallenge) {\n        logger.info(`The WWW-Authenticate header was missing the necessary \"claims\" to perform the Continuous Access Evaluation authentication flow.`);\n        return false;\n    }\n    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {\n        claims: decodeStringToString(parsedChallenge.claims),\n    });\n    if (!accessToken) {\n        return false;\n    }\n    onChallengeOptions.request.headers.set(\"Authorization\", `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n    return true;\n}\n//# sourceMappingURL=authorizeRequestOnClaimChallenge.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n    DefaultScope: \"/.default\",\n    /**\n     * Defines constants for use with HTTP headers.\n     */\n    HeaderConstants: {\n        /**\n         * The Authorization header.\n         */\n        AUTHORIZATION: \"authorization\",\n    },\n};\nfunction isUuid(text) {\n    return /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/.test(text);\n}\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://learn.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge = async (challengeOptions) => {\n    var _a;\n    const requestOptions = requestToOptions(challengeOptions.request);\n    const challenge = getChallenge(challengeOptions.response);\n    if (challenge) {\n        const challengeInfo = parseChallenge(challenge);\n        const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n        const tenantId = extractTenantId(challengeInfo);\n        if (!tenantId) {\n            return false;\n        }\n        const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), { tenantId }));\n        if (!accessToken) {\n            return false;\n        }\n        challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${(_a = accessToken.tokenType) !== null && _a !== void 0 ? _a : \"Bearer\"} ${accessToken.token}`);\n        return true;\n    }\n    return false;\n};\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo) {\n    const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n    const pathSegments = parsedAuthUri.pathname.split(\"/\");\n    const tenantId = pathSegments[1];\n    if (tenantId && isUuid(tenantId)) {\n        return tenantId;\n    }\n    return undefined;\n}\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(challengeOptions, challengeInfo) {\n    if (!challengeInfo.resource_id) {\n        return challengeOptions.scopes;\n    }\n    const challengeScopes = new URL(challengeInfo.resource_id);\n    challengeScopes.pathname = Constants.DefaultScope;\n    let scope = challengeScopes.toString();\n    if (scope === \"https://disk.azure.com/.default\") {\n        // the extra slash is required by the service\n        scope = \"https://disk.azure.com//.default\";\n    }\n    return [scope];\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (response.status === 401 && challenge) {\n        return challenge;\n    }\n    return;\n}\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge) {\n    const bearerChallenge = challenge.slice(\"Bearer \".length);\n    const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter((x) => x);\n    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split(\"=\")));\n    // Key-value pairs to plain object:\n    return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});\n}\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request) {\n    return {\n        abortSignal: request.abortSignal,\n        requestOptions: {\n            timeout: request.timeout,\n        },\n        tracingOptions: request.tracingOptions,\n    };\n}\n//# sourceMappingURL=authorizeRequestOnTenantChallenge.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport function getIdentityTokenEndpointSuffix(tenantId) {\n    if (tenantId === \"adfs\") {\n        return \"oauth2/token\";\n    }\n    else {\n        return \"oauth2/v2.0/token\";\n    }\n}\n//# sourceMappingURL=identityTokenEndpoint.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nconst DefaultScopeSuffix = \"/.default\";\n/**\n * Error message for Service Fabric Managed Identity environment.\n */\nexport const serviceFabricErrorMessage = \"Specifying a `clientId` or `resourceId` is not supported by the Service Fabric managed identity environment. The managed identity configuration is determined by the Service Fabric cluster resource configuration. See https://aka.ms/servicefabricmi for more information\";\n/**\n * Most MSIs send requests to the IMDS endpoint, or a similar endpoint.\n * These are GET requests that require sending a `resource` parameter on the query.\n * This resource can be derived from the scopes received through the getToken call, as long as only one scope is received.\n * Multiple scopes assume that the resulting token will have access to multiple resources, which won't be the case.\n *\n * For that reason, when we encounter multiple scopes, we return undefined.\n * It's up to the individual MSI implementations to throw the errors (which helps us provide less generic errors).\n */\nexport function mapScopesToResource(scopes) {\n    let scope = \"\";\n    if (Array.isArray(scopes)) {\n        if (scopes.length !== 1) {\n            return;\n        }\n        scope = scopes[0];\n    }\n    else if (typeof scopes === \"string\") {\n        scope = scopes;\n    }\n    if (!scope.endsWith(DefaultScopeSuffix)) {\n        return scope;\n    }\n    return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));\n}\n/**\n * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.\n * @param body - A parsed response body from the authentication endpoint.\n */\nexport function parseExpirationTimestamp(body) {\n    if (typeof body.expires_on === \"number\") {\n        return body.expires_on * 1000;\n    }\n    if (typeof body.expires_on === \"string\") {\n        const asNumber = +body.expires_on;\n        if (!isNaN(asNumber)) {\n            return asNumber * 1000;\n        }\n        const asDate = Date.parse(body.expires_on);\n        if (!isNaN(asDate)) {\n            return asDate;\n        }\n    }\n    if (typeof body.expires_in === \"number\") {\n        return Date.now() + body.expires_in * 1000;\n    }\n    throw new Error(`Failed to parse token expiration from body. expires_in=\"${body.expires_in}\", expires_on=\"${body.expires_on}\"`);\n}\n/**\n * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.\n * @param body - A parsed response body from the authentication endpoint.\n */\nexport function parseRefreshTimestamp(body) {\n    if (body.refresh_on) {\n        if (typeof body.refresh_on === \"number\") {\n            return body.refresh_on * 1000;\n        }\n        if (typeof body.refresh_on === \"string\") {\n            const asNumber = +body.refresh_on;\n            if (!isNaN(asNumber)) {\n                return asNumber * 1000;\n            }\n            const asDate = Date.parse(body.refresh_on);\n            if (!isNaN(asDate)) {\n                return asDate;\n            }\n        }\n        throw new Error(`Failed to parse refresh_on from body. refresh_on=\"${body.refresh_on}\"`);\n    }\n    else {\n        return undefined;\n    }\n}\n//# sourceMappingURL=utils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors.js\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint.js\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nimport { logger } from \"../util/logging.js\";\nimport { parseExpirationTimestamp, parseRefreshTimestamp, } from \"../credentials/managedIdentityCredential/utils.js\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options) {\n    // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n    let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n    // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n    if (isNode) {\n        authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n    }\n    // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n    return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient {\n    constructor(options) {\n        var _a, _b;\n        const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n        const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix)\n            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n            : `${packageDetails}`;\n        const baseUri = getIdentityClientAuthorityHost(options);\n        if (!baseUri.startsWith(\"https:\")) {\n            throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n        }\n        super(Object.assign(Object.assign({ requestContentType: \"application/json; charset=utf-8\", retryOptions: {\n                maxRetries: 3,\n            } }, options), { userAgentOptions: {\n                userAgentPrefix,\n            }, baseUri }));\n        this.allowInsecureConnection = false;\n        this.authorityHost = baseUri;\n        this.abortControllers = new Map();\n        this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;\n        // used for WorkloadIdentity\n        this.tokenCredentialOptions = Object.assign({}, options);\n        // used for ManagedIdentity\n        if (options === null || options === void 0 ? void 0 : options.allowInsecureConnection) {\n            this.allowInsecureConnection = options.allowInsecureConnection;\n        }\n    }\n    async sendTokenRequest(request) {\n        logger.info(`IdentityClient: sending token request to [${request.url}]`);\n        const response = await this.sendRequest(request);\n        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n            const parsedBody = JSON.parse(response.bodyAsText);\n            if (!parsedBody.access_token) {\n                return null;\n            }\n            this.logIdentifiers(response);\n            const token = {\n                accessToken: {\n                    token: parsedBody.access_token,\n                    expiresOnTimestamp: parseExpirationTimestamp(parsedBody),\n                    refreshAfterTimestamp: parseRefreshTimestamp(parsedBody),\n                    tokenType: \"Bearer\",\n                },\n                refreshToken: parsedBody.refresh_token,\n            };\n            logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n            return token;\n        }\n        else {\n            const error = new AuthenticationError(response.status, response.bodyAsText);\n            logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n            throw error;\n        }\n    }\n    async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, options = {}) {\n        if (refreshToken === undefined) {\n            return null;\n        }\n        logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n        const refreshParams = {\n            grant_type: \"refresh_token\",\n            client_id: clientId,\n            refresh_token: refreshToken,\n            scope: scopes,\n        };\n        if (clientSecret !== undefined) {\n            refreshParams.client_secret = clientSecret;\n        }\n        const query = new URLSearchParams(refreshParams);\n        return tracingClient.withSpan(\"IdentityClient.refreshAccessToken\", options, async (updatedOptions) => {\n            try {\n                const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n                const request = createPipelineRequest({\n                    url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,\n                    method: \"POST\",\n                    body: query.toString(),\n                    abortSignal: options.abortSignal,\n                    headers: createHttpHeaders({\n                        Accept: \"application/json\",\n                        \"Content-Type\": \"application/x-www-form-urlencoded\",\n                    }),\n                    tracingOptions: updatedOptions.tracingOptions,\n                });\n                const response = await this.sendTokenRequest(request);\n                logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n                return response;\n            }\n            catch (err) {\n                if (err.name === AuthenticationErrorName &&\n                    err.errorResponse.error === \"interaction_required\") {\n                    // It's likely that the refresh token has expired, so\n                    // return null so that the credential implementation will\n                    // initiate the authentication flow again.\n                    logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n                    return null;\n                }\n                else {\n                    logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n                    throw err;\n                }\n            }\n        });\n    }\n    // Here is a custom layer that allows us to abort requests that go through MSAL,\n    // since MSAL doesn't allow us to pass options all the way through.\n    generateAbortSignal(correlationId) {\n        const controller = new AbortController();\n        const controllers = this.abortControllers.get(correlationId) || [];\n        controllers.push(controller);\n        this.abortControllers.set(correlationId, controllers);\n        const existingOnAbort = controller.signal.onabort;\n        controller.signal.onabort = (...params) => {\n            this.abortControllers.set(correlationId, undefined);\n            if (existingOnAbort) {\n                existingOnAbort.apply(controller.signal, params);\n            }\n        };\n        return controller.signal;\n    }\n    abortRequests(correlationId) {\n        const key = correlationId || noCorrelationId;\n        const controllers = [\n            ...(this.abortControllers.get(key) || []),\n            // MSAL passes no correlation ID to the get requests...\n            ...(this.abortControllers.get(noCorrelationId) || []),\n        ];\n        if (!controllers.length) {\n            return;\n        }\n        for (const controller of controllers) {\n            controller.abort();\n        }\n        this.abortControllers.set(key, undefined);\n    }\n    getCorrelationId(options) {\n        var _a;\n        const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map((part) => part.split(\"=\")).find(([key]) => key === \"client-request-id\");\n        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n    }\n    // The MSAL network module methods follow\n    async sendGetRequestAsync(url, options) {\n        const request = createPipelineRequest({\n            url,\n            method: \"GET\",\n            body: options === null || options === void 0 ? void 0 : options.body,\n            allowInsecureConnection: this.allowInsecureConnection,\n            headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n            abortSignal: this.generateAbortSignal(noCorrelationId),\n        });\n        const response = await this.sendRequest(request);\n        this.logIdentifiers(response);\n        return {\n            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n            headers: response.headers.toJSON(),\n            status: response.status,\n        };\n    }\n    async sendPostRequestAsync(url, options) {\n        const request = createPipelineRequest({\n            url,\n            method: \"POST\",\n            body: options === null || options === void 0 ? void 0 : options.body,\n            headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n            allowInsecureConnection: this.allowInsecureConnection,\n            // MSAL doesn't send the correlation ID on the get requests.\n            abortSignal: this.generateAbortSignal(this.getCorrelationId(options)),\n        });\n        const response = await this.sendRequest(request);\n        this.logIdentifiers(response);\n        return {\n            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n            headers: response.headers.toJSON(),\n            status: response.status,\n        };\n    }\n    /**\n     *\n     * @internal\n     */\n    getTokenCredentialOptions() {\n        return this.tokenCredentialOptions;\n    }\n    /**\n     * If allowLoggingAccountIdentifiers was set on the constructor options\n     * we try to log the account identifiers by parsing the received access token.\n     *\n     * The account identifiers we try to log are:\n     * - `appid`: The application or Client Identifier.\n     * - `upn`: User Principal Name.\n     *   - It might not be available in some authentication scenarios.\n     *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n     * - `tid`: Tenant Identifier.\n     * - `oid`: Object Identifier of the authenticated user.\n     */\n    logIdentifiers(response) {\n        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n            return;\n        }\n        const unavailableUpn = \"No User Principal Name available\";\n        try {\n            const parsed = response.parsedBody || JSON.parse(response.bodyAsText);\n            const accessToken = parsed.access_token;\n            if (!accessToken) {\n                // Without an access token allowLoggingAccountIdentifiers isn't useful.\n                return;\n            }\n            const base64Metadata = accessToken.split(\".\")[1];\n            const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, \"base64\").toString(\"utf8\"));\n            logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);\n        }\n        catch (e) {\n            logger.warning(\"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\", e.message);\n        }\n    }\n}\n//# sourceMappingURL=identityClient.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, } from \"../util/tenantIdUtils.js\";\nimport { IdentityClient } from \"../client/identityClient.js\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nconst logger = credentialLogger(\"ClientSecretCredential\");\n// This credential is exported on browser bundles for development purposes.\n// For this credential to work in browsers, browsers would need to have security features disabled.\n// Please do not disable your browser security features.\n/**\n * Enables authentication to Microsoft Entra ID using a client secret\n * that was generated for an App Registration.  More information on how\n * to configure a client secret can be found here:\n *\n * https://learn.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application\n *\n */\nexport class ClientSecretCredential {\n    /**\n     * Creates an instance of the ClientSecretCredential with the details\n     * needed to authenticate against Microsoft Entra ID with a client\n     * secret.\n     *\n     * @param tenantId - The Microsoft Entra tenant (directory) ID.\n     * @param clientId - The client (application) ID of an App Registration in the tenant.\n     * @param clientSecret - A client secret that was generated for the App Registration.\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(tenantId, clientId, clientSecret, options) {\n        this.identityClient = new IdentityClient(options);\n        this.tenantId = tenantId;\n        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if\n     * successful.  If authentication cannot be performed at this time, this method may\n     * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n     * containing failure details will be thrown.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {\n            const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n            const query = new URLSearchParams({\n                response_type: \"token\",\n                grant_type: \"client_credentials\",\n                client_id: this.clientId,\n                client_secret: this.clientSecret,\n                scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \"),\n            });\n            try {\n                const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n                const request = createPipelineRequest({\n                    url: `${this.identityClient.authorityHost}/${tenantId}/${urlSuffix}`,\n                    method: \"POST\",\n                    body: query.toString(),\n                    headers: createHttpHeaders({\n                        Accept: \"application/json\",\n                        \"Content-Type\": \"application/x-www-form-urlencoded\",\n                    }),\n                    abortSignal: options && options.abortSignal,\n                    tracingOptions: newOptions === null || newOptions === void 0 ? void 0 : newOptions.tracingOptions,\n                });\n                const tokenResponse = await this.identityClient.sendTokenRequest(request);\n                logger.getToken.info(formatSuccess(scopes));\n                return (tokenResponse && tokenResponse.accessToken) || null;\n            }\n            catch (err) {\n                logger.getToken.info(formatError(scopes, err));\n                throw err;\n            }\n        });\n    }\n}\n//# sourceMappingURL=clientSecretCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"EnvironmentCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"EnvironmentCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using client secret\n * details configured in environment variables\n */\nexport class EnvironmentCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=environmentCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"ClientCertificateCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"ClientCertificateCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using a PEM-encoded\n * certificate that is assigned to an App Registration.\n */\nexport class ClientCertificateCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=clientCertificateCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"ClientAssertionCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"ClientAssertionCredential\");\n/**\n * Authenticates a service principal with a JWT assertion.\n */\nexport class ClientAssertionCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=clientAssertionCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzureCliCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzureCliCredential\");\n/**\n * This credential will use the currently logged-in user login information\n * via the Azure CLI ('az') commandline tool.\n */\nexport class AzureCliCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azureCliCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzureDeveloperCliCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzureDeveloperCliCredential\");\n/**\n * This credential will use the currently logged-in user login information\n * via the Azure Developer CLI ('azd') commandline tool.\n */\nexport class AzureDeveloperCliCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azureDeveloperCliCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { formatError } from \"./logging.js\";\n/**\n * Ensures the scopes value is an array.\n * @internal\n */\nexport function ensureScopes(scopes) {\n    return Array.isArray(scopes) ? scopes : [scopes];\n}\n/**\n * Throws if the received scope is not valid.\n * @internal\n */\nexport function ensureValidScopeForDevTimeCreds(scope, logger) {\n    if (!scope.match(/^[0-9a-zA-Z-_.:/]+$/)) {\n        const error = new Error(\"Invalid scope was specified by the user or calling client\");\n        logger.getToken.info(formatError(scope, error));\n        throw error;\n    }\n}\n/**\n * Returns the resource out of a scope.\n * @internal\n */\nexport function getScopeResource(scope) {\n    return scope.replace(/\\/.default$/, \"\");\n}\n//# sourceMappingURL=scopeUtils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport * as msalBrowser from \"@azure/msal-browser\";\nimport { defaultLoggerCallback, ensureValidMsalToken, getAuthority, getKnownAuthorities, getMSALLogLevel, handleMsalError, msalToPublic, publicToMsal, } from \"../utils.js\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../../errors.js\";\nimport { getLogLevel } from \"@azure/logger\";\nimport { formatSuccess } from \"../../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, resolveTenantId, } from \"../../util/tenantIdUtils.js\";\nimport { DefaultTenantId } from \"../../constants.js\";\n// We keep a copy of the redirect hash.\n// Check if self and location object is defined.\nconst isLocationDefined = typeof self !== \"undefined\" && self.location !== undefined;\n/**\n * Generates a MSAL configuration that generally works for browsers\n * @internal\n */\nfunction generateMsalBrowserConfiguration(options) {\n    var _a;\n    const tenantId = options.tenantId || DefaultTenantId;\n    const authority = getAuthority(tenantId, options.authorityHost);\n    return {\n        auth: {\n            clientId: options.clientId,\n            authority,\n            knownAuthorities: getKnownAuthorities(tenantId, authority, options.disableInstanceDiscovery),\n            // If the users picked redirect as their login style,\n            // but they didn't provide a redirectUri,\n            // we can try to use the current page we're in as a default value.\n            redirectUri: options.redirectUri || (isLocationDefined ? self.location.origin : undefined),\n        },\n        cache: {\n            cacheLocation: \"sessionStorage\",\n            storeAuthStateInCookie: true, // Set to true to improve the experience on IE11 and Edge.\n        },\n        system: {\n            loggerOptions: {\n                loggerCallback: defaultLoggerCallback(options.logger, \"Browser\"),\n                logLevel: getMSALLogLevel(getLogLevel()),\n                piiLoggingEnabled: (_a = options.loggingOptions) === null || _a === void 0 ? void 0 : _a.enableUnsafeSupportLogging,\n            },\n        },\n    };\n}\n// We keep a copy of the redirect hash.\nconst redirectHash = isLocationDefined ? self.location.hash : undefined;\n/**\n * Uses MSAL Browser 2.X for browser authentication,\n * which uses the [Auth Code Flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow).\n * @internal\n */\nexport function createMsalBrowserClient(options) {\n    var _a;\n    const loginStyle = options.loginStyle;\n    if (!options.clientId) {\n        throw new CredentialUnavailableError(\"A client ID is required in browsers\");\n    }\n    const clientId = options.clientId;\n    const logger = options.logger;\n    const tenantId = resolveTenantId(logger, options.tenantId, options.clientId);\n    const additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds((_a = options === null || options === void 0 ? void 0 : options.tokenCredentialOptions) === null || _a === void 0 ? void 0 : _a.additionallyAllowedTenants);\n    const authorityHost = options.authorityHost;\n    const msalConfig = generateMsalBrowserConfiguration(options);\n    const disableAutomaticAuthentication = options.disableAutomaticAuthentication;\n    const loginHint = options.loginHint;\n    let account;\n    if (options.authenticationRecord) {\n        account = Object.assign(Object.assign({}, options.authenticationRecord), { tenantId });\n    }\n    // This variable should only be used through calling `getApp` function\n    let app;\n    /**\n     * Return the MSAL account if not set yet\n     * @returns MSAL application\n     */\n    async function getApp() {\n        if (!app) {\n            // Prepare the MSAL application\n            app = await msalBrowser.PublicClientApplication.createPublicClientApplication(msalConfig);\n            // setting the account right after the app is created.\n            if (account) {\n                app.setActiveAccount(publicToMsal(account));\n            }\n        }\n        return app;\n    }\n    /**\n     * Loads the account based on the result of the authentication.\n     * If no result was received, tries to load the account from the cache.\n     * @param result - Result object received from MSAL.\n     */\n    async function handleBrowserResult(result) {\n        try {\n            const msalApp = await getApp();\n            if (result && result.account) {\n                logger.info(`MSAL Browser V2 authentication successful.`);\n                msalApp.setActiveAccount(result.account);\n                return msalToPublic(clientId, result.account);\n            }\n            // If by this point we happen to have an active account, we should stop trying to parse this.\n            const activeAccount = msalApp.getActiveAccount();\n            if (activeAccount) {\n                return msalToPublic(clientId, activeAccount);\n            }\n            // If we don't have an active account, we try to activate it from all the already loaded accounts.\n            const allAccounts = app.getAllAccounts();\n            if (allAccounts.length > 1) {\n                // If there's more than one account in memory, we force the user to authenticate again.\n                // At this point we can't identify which account should this credential work with,\n                // since at this point the user won't have provided enough information.\n                // We log a message in case that helps.\n                logger.info(`More than one account was found authenticated for this Client ID and Tenant ID.\n  However, no \"authenticationRecord\" has been provided for this credential,\n  therefore we're unable to pick between these accounts.\n  A new login attempt will be requested, to ensure the correct account is picked.\n  To work with multiple accounts for the same Client ID and Tenant ID, please provide an \"authenticationRecord\" when initializing \"InteractiveBrowserCredential\".`);\n                // To safely trigger a new login, we're also ensuring the local cache is cleared up for this MSAL object.\n                // However, we want to avoid kicking the user out of their authentication on the Azure side.\n                // We do this by calling to logout while specifying a `onRedirectNavigate` that returns false.\n                await msalApp.logout({\n                    onRedirectNavigate: () => false,\n                });\n                return;\n            }\n            // If there's only one account for this MSAL object, we can safely activate it.\n            if (allAccounts.length === 1) {\n                const msalAccount = allAccounts[0];\n                msalApp.setActiveAccount(msalAccount);\n                return msalToPublic(clientId, msalAccount);\n            }\n            logger.info(`No accounts were found through MSAL.`);\n        }\n        catch (e) {\n            logger.info(`Failed to acquire token through MSAL. ${e.message}`);\n        }\n        return;\n    }\n    /**\n     * Handles the MSAL authentication result.\n     * If the result has an account, we update the local account reference.\n     * If the token received is invalid, an error will be thrown depending on what's missing.\n     */\n    function handleResult(scopes, result, getTokenOptions) {\n        var _a;\n        if (result === null || result === void 0 ? void 0 : result.account) {\n            account = msalToPublic(clientId, result.account);\n        }\n        ensureValidMsalToken(scopes, result, getTokenOptions);\n        logger.getToken.info(formatSuccess(scopes));\n        return {\n            token: result.accessToken,\n            expiresOnTimestamp: result.expiresOn.getTime(),\n            refreshAfterTimestamp: (_a = result.refreshOn) === null || _a === void 0 ? void 0 : _a.getTime(),\n            tokenType: \"Bearer\",\n        };\n    }\n    /**\n     * Uses MSAL to handle the redirect.\n     */\n    async function handleRedirect() {\n        const msalApp = await getApp();\n        return handleBrowserResult((await msalApp.handleRedirectPromise(redirectHash)) || undefined);\n    }\n    /**\n     * Uses MSAL to retrieve the active account.\n     */\n    async function getActiveAccount() {\n        const msalApp = await getApp();\n        const activeAccount = msalApp.getActiveAccount();\n        if (!activeAccount) {\n            return;\n        }\n        return msalToPublic(clientId, activeAccount);\n    }\n    /**\n     * Uses MSAL to trigger a redirect or a popup login.\n     */\n    async function login(scopes = []) {\n        const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];\n        const loginRequest = {\n            scopes: arrayScopes,\n            loginHint: loginHint,\n        };\n        const msalApp = await getApp();\n        switch (loginStyle) {\n            case \"redirect\": {\n                await app.loginRedirect(loginRequest);\n                return;\n            }\n            case \"popup\":\n                return handleBrowserResult(await msalApp.loginPopup(loginRequest));\n        }\n    }\n    /**\n     * Tries to retrieve the token silently using MSAL.\n     */\n    async function getTokenSilent(scopes, getTokenOptions) {\n        const activeAccount = await getActiveAccount();\n        if (!activeAccount) {\n            throw new AuthenticationRequiredError({\n                scopes,\n                getTokenOptions,\n                message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\",\n            });\n        }\n        const parameters = {\n            authority: (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.authority) || msalConfig.auth.authority,\n            correlationId: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.correlationId,\n            claims: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.claims,\n            account: publicToMsal(activeAccount),\n            forceRefresh: false,\n            scopes,\n        };\n        try {\n            logger.info(\"Attempting to acquire token silently\");\n            const msalApp = await getApp();\n            const response = await msalApp.acquireTokenSilent(parameters);\n            return handleResult(scopes, response);\n        }\n        catch (err) {\n            throw handleMsalError(scopes, err, options);\n        }\n    }\n    /**\n     * Attempts to retrieve the token in the browser through interactive methods.\n     */\n    async function getTokenInteractive(scopes, getTokenOptions) {\n        const activeAccount = await getActiveAccount();\n        if (!activeAccount) {\n            throw new AuthenticationRequiredError({\n                scopes,\n                getTokenOptions,\n                message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\",\n            });\n        }\n        const parameters = {\n            authority: (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.authority) || msalConfig.auth.authority,\n            correlationId: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.correlationId,\n            claims: getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.claims,\n            account: publicToMsal(activeAccount),\n            loginHint: loginHint,\n            scopes,\n        };\n        const msalApp = await getApp();\n        switch (loginStyle) {\n            case \"redirect\":\n                // This will go out of the page.\n                // Once the InteractiveBrowserCredential is initialized again,\n                // we'll load the MSAL account in the constructor.\n                await msalApp.acquireTokenRedirect(parameters);\n                return { token: \"\", expiresOnTimestamp: 0, tokenType: \"Bearer\" };\n            case \"popup\":\n                return handleResult(scopes, await app.acquireTokenPopup(parameters));\n        }\n    }\n    /**\n     * Attempts to get token through the silent flow.\n     * If failed, get token through interactive method with `doGetToken` method.\n     */\n    async function getToken(scopes, getTokenOptions = {}) {\n        const getTokenTenantId = processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds) ||\n            tenantId;\n        if (!getTokenOptions.authority) {\n            getTokenOptions.authority = getAuthority(getTokenTenantId, authorityHost);\n        }\n        // We ensure that redirection is handled at this point.\n        await handleRedirect();\n        if (!(await getActiveAccount()) && !disableAutomaticAuthentication) {\n            await login(scopes);\n        }\n        // Attempts to get the token silently; else, falls back to interactive method.\n        try {\n            return await getTokenSilent(scopes, getTokenOptions);\n        }\n        catch (err) {\n            if (err.name !== \"AuthenticationRequiredError\") {\n                throw err;\n            }\n            if (getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.disableAutomaticAuthentication) {\n                throw new AuthenticationRequiredError({\n                    scopes,\n                    getTokenOptions,\n                    message: \"Automatic authentication has been disabled. You may call the authenticate() method.\",\n                });\n            }\n            logger.info(`Silent authentication failed, falling back to interactive method ${loginStyle}`);\n            return getTokenInteractive(scopes, getTokenOptions);\n        }\n    }\n    return {\n        getActiveAccount,\n        getToken,\n    };\n}\n//# sourceMappingURL=msalBrowserCommon.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, } from \"../util/tenantIdUtils.js\";\nimport { ensureScopes } from \"../util/scopeUtils.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nimport { createMsalBrowserClient } from \"../msal/browserFlows/msalBrowserCommon.js\";\nconst logger = credentialLogger(\"InteractiveBrowserCredential\");\n/**\n * Enables authentication to Microsoft Entra ID inside of the web browser\n * using the interactive login flow.\n */\nexport class InteractiveBrowserCredential {\n    /**\n     * Creates an instance of the InteractiveBrowserCredential with the\n     * details needed to authenticate against Microsoft Entra ID with\n     * a user identity.\n     *\n     * This credential uses the [Authorization Code Flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow).\n     * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.\n     * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.\n     *\n     * It's recommended that the Microsoft Entra Applications used are configured to authenticate using Single Page Applications.\n     * More information here: [link](https://learn.microsoft.com/en-us/azure/active-directory/develop/scenario-spa-app-registration#redirect-uri-msaljs-20-with-auth-code-flow).\n     *\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(options) {\n        if (!(options === null || options === void 0 ? void 0 : options.clientId)) {\n            const error = new Error(\"The parameter `clientId` cannot be left undefined for the `InteractiveBrowserCredential`\");\n            logger.info(formatError(\"\", error));\n            throw error;\n        }\n        this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;\n        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);\n        const browserOptions = options;\n        const loginStyle = browserOptions.loginStyle || \"popup\";\n        const loginStyles = [\"redirect\", \"popup\"];\n        if (loginStyles.indexOf(loginStyle) === -1) {\n            const error = new Error(`Invalid loginStyle: ${browserOptions.loginStyle}. Should be any of the following: ${loginStyles.join(\", \")}.`);\n            logger.info(formatError(\"\", error));\n            throw error;\n        }\n        const msalOptions = Object.assign(Object.assign({}, options), { tokenCredentialOptions: options, logger, loginStyle: loginStyle, redirectUri: typeof options.redirectUri === \"function\" ? options.redirectUri() : options.redirectUri });\n        this.msalClient = createMsalBrowserClient(msalOptions);\n        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if successful.\n     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.\n     *\n     * If the user provided the option `disableAutomaticAuthentication`,\n     * once the token can't be retrieved silently,\n     * this method won't attempt to request user interaction to retrieve the token.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {\n            const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n            newOptions.tenantId = tenantId;\n            const arrayScopes = ensureScopes(scopes);\n            return this.msalClient.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));\n        });\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if successful.\n     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.\n     *\n     * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                  TokenCredential implementation might make.\n     */\n    async authenticate(scopes, options = {}) {\n        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {\n            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];\n            await this.msalClient.getToken(arrayScopes, newOptions);\n            return this.msalClient.getActiveAccount();\n        });\n    }\n}\n//# sourceMappingURL=interactiveBrowserCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"ManagedIdentityCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"ManagedIdentityCredential\");\nexport class ManagedIdentityCredential {\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    async getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=index-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"DeviceCodeCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"DeviceCodeCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using a device code\n * that the user can enter into https://microsoft.com/devicelogin.\n */\nexport class DeviceCodeCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=deviceCodeCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzurePipelinesCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzurePipelinesCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using a PEM-encoded\n * certificate that is assigned to an App Registration.\n */\nexport class AzurePipelinesCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azurePipelinesCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AuthorizationCodeCredential is not supported in the browser. InteractiveBrowserCredential is more appropriate for this use case.\");\nconst logger = credentialLogger(\"AuthorizationCodeCredential\");\nexport class AuthorizationCodeCredential {\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=authorizationCodeCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzurePowerShellCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzurePowerShellCredential\");\n/**\n * This credential will use the currently-logged-in user's login information via the Azure Power Shell command line tool.\n */\nexport class AzurePowerShellCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azurePowerShellCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { checkTenantId, processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, } from \"../util/tenantIdUtils.js\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { credentialLogger, formatSuccess } from \"../util/logging.js\";\nimport { IdentityClient } from \"../client/identityClient.js\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nconst logger = credentialLogger(\"UsernamePasswordCredential\");\n/**\n * Enables authentication to Microsoft Entra ID with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n *\n * @deprecated UsernamePasswordCredential is deprecated. Use a more secure credential. See https://aka.ms/azsdk/identity/mfa for details.\n */\nexport class UsernamePasswordCredential {\n    /**\n     * Creates an instance of the UsernamePasswordCredential with the details\n     * needed to authenticate against Microsoft Entra ID with a username\n     * and password.\n     *\n     * @param tenantIdOrName - The Microsoft Entra tenant (directory) ID or name.\n     * @param clientId - The client (application) ID of an App Registration in the tenant.\n     * @param username - The user account's e-mail address (user name).\n     * @param password - The user account's account password\n     * @param options - Options for configuring the client which makes the authentication request.\n     *\n     */\n    constructor(tenantIdOrName, clientId, username, password, options) {\n        checkTenantId(logger, tenantIdOrName);\n        this.identityClient = new IdentityClient(options);\n        this.tenantId = tenantIdOrName;\n        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);\n        this.clientId = clientId;\n        this.username = username;\n        this.password = password;\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if\n     * successful.  If authentication cannot be performed at this time, this method may\n     * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n     * containing failure details will be thrown.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        return tracingClient.withSpan(\"UsernamePasswordCredential.getToken\", options, async (newOptions) => {\n            const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n            newOptions.tenantId = tenantId;\n            const urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);\n            const params = new URLSearchParams({\n                response_type: \"token\",\n                grant_type: \"password\",\n                client_id: this.clientId,\n                username: this.username,\n                password: this.password,\n                scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \"),\n            });\n            const webResource = createPipelineRequest({\n                url: `${this.identityClient.authorityHost}/${this.tenantId}/${urlSuffix}`,\n                method: \"POST\",\n                body: params.toString(),\n                headers: createHttpHeaders({\n                    Accept: \"application/json\",\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                }),\n                abortSignal: options && options.abortSignal,\n                tracingOptions: newOptions.tracingOptions,\n            });\n            const tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n            logger.getToken.info(formatSuccess(scopes));\n            return (tokenResponse && tokenResponse.accessToken) || null;\n        });\n    }\n}\n//# sourceMappingURL=usernamePasswordCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"VisualStudioCodeCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"VisualStudioCodeCredential\");\nexport const vsCodeCredentialControl = {\n    set vsCodeCredentialFinder(_finder) {\n        throw new Error(\"Attempted to register a VisualStudioCodeCredential provider plugin in the browser. This environment is not supported by VisualStudioCodeCredential.\");\n    },\n};\n/**\n * Connects to Azure using the credential provided by the VSCode extension 'Azure Account'.\n *\n * @deprecated This credential is deprecated because the VS Code Azure Account extension on which this credential\n * relies has been deprecated. Users should use other dev-time credentials, such as {@link AzureCliCredential},\n * {@link AzureDeveloperCliCredential}, or {@link AzurePowerShellCredential} for their\n * local development needs. See Azure account extension deprecation notice [here](https://github.com/microsoft/vscode-azure-account/issues/964).\n */\nexport class VisualStudioCodeCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=visualStudioCodeCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst credentialName = \"OnBehalfOfCredential\";\nconst BrowserNotSupportedError = new Error(`${credentialName}: Not supported in the browser.`);\nconst logger = credentialLogger(credentialName);\n/**\n * Enables authentication to Microsoft Entra ID using the [On Behalf Of flow](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow).\n */\nexport class OnBehalfOfCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=onBehalfOfCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"WorkloadIdentityCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"WorkloadIdentityCredential\");\n/**\n * WorkloadIdentityCredential supports Microsoft Entra Workload ID authentication on Kubernetes.\n * Refer to <a href=\"https://learn.microsoft.com/azure/aks/workload-identity-overview\">Microsoft Entra Workload ID</a>\n * for more information.\n */\nexport class WorkloadIdentityCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    /**\n     * Only available in Node.js\n     */\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=workloadIdentityCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { bearerTokenAuthenticationPolicy, createEmptyPipeline, createPipelineRequest, } from \"@azure/core-rest-pipeline\";\n/**\n * Returns a callback that provides a bearer token.\n * For example, the bearer token can be used to authenticate a request as follows:\n * ```ts snippet:token_provider_example\n * import { DefaultAzureCredential, getBearerTokenProvider } from \"@azure/identity\";\n * import { createPipelineRequest } from \"@azure/core-rest-pipeline\";\n *\n * const credential = new DefaultAzureCredential();\n * const scope = \"https://cognitiveservices.azure.com/.default\";\n * const getAccessToken = getBearerTokenProvider(credential, scope);\n * const token = await getAccessToken();\n *\n * // usage\n * const request = createPipelineRequest({ url: \"https://example.com\" });\n * request.headers.set(\"Authorization\", `Bearer ${token}`);\n * ```\n *\n * @param credential - The credential used to authenticate the request.\n * @param scopes - The scopes required for the bearer token.\n * @param options - Options to configure the token provider.\n * @returns a callback that provides a bearer token.\n */\nexport function getBearerTokenProvider(credential, scopes, options) {\n    const { abortSignal, tracingOptions } = options || {};\n    const pipeline = createEmptyPipeline();\n    pipeline.addPolicy(bearerTokenAuthenticationPolicy({ credential, scopes }));\n    async function getRefreshedToken() {\n        var _a;\n        // Create a pipeline with just the bearer token policy\n        // and run a dummy request through it to get the token\n        const res = await pipeline.sendRequest({\n            sendRequest: (request) => Promise.resolve({\n                request,\n                status: 200,\n                headers: request.headers,\n            }),\n        }, createPipelineRequest({\n            url: \"https://example.com\",\n            abortSignal,\n            tracingOptions,\n        }));\n        const accessToken = (_a = res.headers.get(\"authorization\")) === null || _a === void 0 ? void 0 : _a.split(\" \")[1];\n        if (!accessToken) {\n            throw new Error(\"Failed to get access token\");\n        }\n        return accessToken;\n    }\n    return getRefreshedToken;\n}\n//# sourceMappingURL=tokenProvider.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport * from \"./plugins/consumer.js\";\nimport { DefaultAzureCredential } from \"./credentials/defaultAzureCredential.js\";\nexport { AuthenticationError, AggregateAuthenticationError, AuthenticationErrorName, AggregateAuthenticationErrorName, CredentialUnavailableError, CredentialUnavailableErrorName, AuthenticationRequiredError, } from \"./errors.js\";\nexport { serializeAuthenticationRecord, deserializeAuthenticationRecord } from \"./msal/utils.js\";\nexport { ChainedTokenCredential } from \"./credentials/chainedTokenCredential.js\";\nexport { ClientSecretCredential } from \"./credentials/clientSecretCredential.js\";\nexport { DefaultAzureCredential } from \"./credentials/defaultAzureCredential.js\";\nexport { EnvironmentCredential } from \"./credentials/environmentCredential.js\";\nexport { ClientCertificateCredential } from \"./credentials/clientCertificateCredential.js\";\nexport { ClientAssertionCredential } from \"./credentials/clientAssertionCredential.js\";\nexport { AzureCliCredential } from \"./credentials/azureCliCredential.js\";\nexport { AzureDeveloperCliCredential } from \"./credentials/azureDeveloperCliCredential.js\";\nexport { InteractiveBrowserCredential } from \"./credentials/interactiveBrowserCredential.js\";\nexport { ManagedIdentityCredential } from \"./credentials/managedIdentityCredential/index.js\";\nexport { DeviceCodeCredential } from \"./credentials/deviceCodeCredential.js\";\nexport { AzurePipelinesCredential as AzurePipelinesCredential } from \"./credentials/azurePipelinesCredential.js\";\nexport { AuthorizationCodeCredential } from \"./credentials/authorizationCodeCredential.js\";\nexport { AzurePowerShellCredential } from \"./credentials/azurePowerShellCredential.js\";\nexport { UsernamePasswordCredential } from \"./credentials/usernamePasswordCredential.js\";\nexport { VisualStudioCodeCredential } from \"./credentials/visualStudioCodeCredential.js\";\nexport { OnBehalfOfCredential } from \"./credentials/onBehalfOfCredential.js\";\nexport { WorkloadIdentityCredential } from \"./credentials/workloadIdentityCredential.js\";\nexport { logger } from \"./util/logging.js\";\nexport { AzureAuthorityHosts } from \"./constants.js\";\n/**\n * Returns a new instance of the {@link DefaultAzureCredential}.\n */\nexport function getDefaultAzureCredential() {\n    return new DefaultAzureCredential();\n}\nexport { getBearerTokenProvider } from \"./tokenProvider.js\";\n//# sourceMappingURL=index.js.map"],"names":["context","AzureLogger","setLogLevel","level","createClientLogger","namespace","logger","processEnvVars","supportedEnvVars","acc","envVariable","process","logEnvVars","credentialName","assigned","scope","error","message","credentialLoggerInstance","title","parent","log","fullTitle","info","warning","verbose","credentialLogger","credLogger","isErrorResponse","errorResponse","CredentialUnavailableErrorName","options","AuthenticationErrorName","AuthenticationError","statusCode","errorBody","convertOAuthErrorResponseToErrorResponse","oauthErrorResponse","AggregateAuthenticationErrorName","AggregateAuthenticationError","errors","errorMessage","errorDetail","SDK_VERSION","AzureAuthorityHosts","CACHE_CAE_SUFFIX","CACHE_NON_CAE_SUFFIX","DEFAULT_TOKEN_CACHE_NAME","knownContextKeys","createTracingContext","TracingContextImpl","initialContext","key","value","newContext","createDefaultTracingSpan","createDefaultInstrumenter","_name","spanOptions","_context","callback","callbackArgs","useInstrumenter","instrumenter","getInstrumenter","createTracingClient","packageName","packageVersion","startSpan","name","operationOptions","_a","startSpanResult","tracingContext","span","updatedOptions","withSpan","result","withContext","err","parseTraceparentHeader","traceparentHeader","createRequestHeaders","ChainedTokenCredential","sources","scopes","token","successfulCredential","i","BrowserNotSupportedError","_tokenCredentialOptions","createAbortablePromise","buildPromise","cleanupBeforeAbort","abortSignal","abortErrorMsg","resolve","reject","rejectOnAbort","removeListeners","onAbort","x","StandardAbortMessage","delay","timeInMs","calculateRetryDelay","retryAttempt","config","exponentialDelay","clampedDelay","getErrorMessage","e","stringified","computeSha256Hash","content","encoding","computeSha256Hmac","stringToSign","min","max","isError","isObject","input","randomUUID","isBrowser","isBun","isDeno","isNodeRuntime","isReactNative","isWebWorker","uint8ArrayToString","bytes","format","stringToUint8Array","LatestAuthenticationRecordVersion","msalToken","getTokenOptions","getAuthorityHost","authorityHost","tenantId","host","disableInstanceDiscovery","platform","containsPii","logLevel","msalError","account","clientId","serializeAuthenticationRecord","record","deserializeAuthenticationRecord","serializedRecord","parsed","logPolicyName","logPolicy","redirectPolicyName","redirectPolicy","getHeaderName","getBrowserInfo","userAgent","browserRegexes","browser","match","getBrandVersionString","brands","brandOrder","brand","foundBrand","b","setPlatformSpecificData","map","localNavigator","osPlatform","entropyValues","getUserAgentString","telemetryInfo","parts","getUserAgentHeaderName","getUserAgentValue","prefix","runtimeInfo","defaultAgent","UserAgentHeaderName","userAgentPolicyName","userAgentPolicy","userAgentValue","request","next","isNodeReadableStream","unimplementedMethods","rawContent","hasRawContent","getRawContent","blob","createFileFromStream","stream","_b","_c","_d","createFile","multipartPolicyName","multipartPolicy","tspPolicy","part","decompressResponsePolicyName","decompressResponsePolicy","defaultRetryPolicyName","defaultRetryPolicy","formDataPolicyName","formDataPolicy","proxyPolicyName","getDefaultProxySettings","proxyUrl","proxyPolicy","proxySettings","setClientRequestIdPolicyName","setClientRequestIdPolicy","requestIdHeaderName","agentPolicyName","agentPolicy","agent","tlsPolicyName","tlsPolicy","tlsSettings","RestError","isRestError","tracingPolicyName","tracingPolicy","userAgentPromise","sanitizer","tracingClient","tryCreateTracingClient","spanAttributes","tryCreateSpan","response","tryProcessResponse","tryProcessError","headers","serviceRequestId","wrapAbortSignalLike","abortSignalLike","controller","needsCleanup","cleanup","listener","wrapAbortSignalLikePolicyName","wrapAbortSignalLikePolicy","createPipelineFromOptions","pipeline","createDefaultHttpClient","client","rawHeaders","exponentialRetryPolicyName","exponentialRetryPolicy","systemErrorRetryPolicyName","systemErrorRetryPolicy","throttlingRetryPolicyName","throttlingRetryPolicy","retryPolicyLogger","retryPolicy","strategies","DEFAULT_CYCLER_OPTIONS","beginRefresh","getAccessToken","retryIntervalInMs","refreshTimeout","tryGetAccessToken","finalToken","credential","tokenCyclerOptions","refreshWorker","cycler","refresh","_token","reason","tokenOptions","hasClaimChallenge","tenantIdChanged","bearerTokenAuthenticationPolicyName","trySendRequest","defaultAuthorizeRequest","accessToken","isChallengeResponse","authorizeRequestOnCaeChallenge","onChallengeOptions","caeClaims","challengeCallbacks","callbacks","shouldSendRequest","claims","getCaeChallengeClaims","parsedClaim","parseChallenges","challenges","challengeRegex","paramRegex","parsedChallenges","scheme","paramsString","params","paramMatch","auxiliaryAuthenticationHeaderPolicyName","AUTHORIZATION_AUXILIARY_HEADER","sendAuthorizeRequest","auxiliaryAuthenticationHeaderPolicy","credentials","tokenCyclerMap","tokenPromises","auxiliaryTokens","additionallyAllowedTenants","SerializerImpl","modelMappers","isXML","mapper","objectName","failValidation","constraintName","constraintValue","ExclusiveMaximum","ExclusiveMinimum","InclusiveMaximum","InclusiveMinimum","MaxItems","MaxLength","MinItems","MinLength","MultipleOf","Pattern","UniqueItems","pattern","item","ar","object","payload","mapperType","required","nullable","serializeBasicTypes","serializeEnumType","serializeDateTypes","serializeByteArrayType","serializeBase64UrlType","serializeSequenceType","serializeDictionaryType","serializeCompositeType","responseBody","deserializeCompositeType","xmlCharKey","unixTimeToDate","base64UrlToByteArray","deserializeSequenceType","deserializeDictionaryType","createSerializer","trimEnd","str","ch","len","bufferToBase64Url","buffer","splitSerializeName","prop","classes","partialclass","subwords","dateToUnixTime","d","n","typeName","objectType","allowedValues","serializer","isXml","elementType","tempArray","serializedValue","xmlnsKey","valueType","tempDictionary","getXmlObjectValue","resolveAdditionalProperties","additionalProperties","modelMapper","resolveReferencedMapper","className","resolveModelProperties","modelProps","getPolymorphicDiscriminatorRecursively","getPolymorphicMapper","propertyMapper","propName","parentObject","paths","pathName","childObject","propertyObjectName","toSerialize","polymorphicDiscriminator","additionalPropertiesMapper","propNames","clientPropName","pn","xmlNamespace","isSpecialXmlProperty","propertyName","instance","handledPropertyNames","serializedName","xmlName","xmlElementName","headerCollectionPrefix","dictionary","headerKey","wrapped","elementList","property","propertyInstance","res","steps","arrayInstance","k","v","isAdditionalProperty","responsePropName","element","getIndexDiscriminator","discriminators","discriminatorValue","typeNamesToCheck","currentName","indexDiscriminator","polymorphicPropertyName","discriminatorName","polymorphicMapper","getPolymorphicDiscriminatorSafely","MapperTypeNames","getOperationArgumentValueFromParameter","operationArguments","parameter","fallbackObject","parameterPath","parameterMapper","propertySearchResult","getPropertyFromParameterPath","useDefaultValue","propertyPath","propertyValue","parameterPathPart","originalRequestSymbol","hasOriginalRequest","getOperationRequestInfo","defaultJsonContentTypes","defaultXmlContentTypes","deserializationPolicyName","deserializationPolicy","_e","_f","_g","jsonContentTypes","xmlContentTypes","parseXML","serializerOptions","deserializeResponseBody","getOperationResponseMap","parsedResponse","operationInfo","operationSpec","shouldDeserializeResponse","shouldDeserialize","parse","responseSpec","shouldReturnResponse","handleErrorResponse","valueToDeserialize","deserializeError","isOperationSpecEmpty","expectedStatusCodes","isSuccessByStatus","errorResponseSpec","initialErrorMessage","defaultBodyMapper","defaultHeadersMapper","parsedBody","deserializedError","elementName","internalError","defaultError","operationResponse","opts","text","contentType","contentComponents","component","body","msg","errCode","getStreamingResponseStatusCodes","getPathStringFromParameter","serializationPolicyName","serializationPolicy","stringifyXML","serializeHeaders","serializeRequestBody","headerParameter","headerValue","customHeaders","customHeaderName","bodyMapper","xmlNamespacePrefix","requestBodyParameterPathString","isStream","getXmlValueWithNamespace","prepareXMLRootList","formDataParameter","formDataParameterValue","formDataParameterPropertyName","obj","xmlNamespaceKey","createClientPipeline","isPrimitiveBody","mapperTypeName","validateISODuration","validUuidRegex","uuid","handleNullableResponseAndWrappableBody","responseObject","combinedHeadersAndBody","flattenResponse","fullResponse","parsedHeaders","isNullable","expectedBodyTypeName","modelProperties","isPageableResponse","arrayResponse","cachedHttpClient","getCachedDefaultHttpClient","CollectionFormatToDelimiterMap","getRequestUrl","baseUri","urlReplacements","calculateUrlReplacements","isAbsolutePath","requestUrl","replaceAll","path","isAbsoluteUrl","appendPath","queryParams","sequenceParams","calculateQueryParameters","appendQueryParams","replacements","searchValue","replaceValue","urlParameter","urlParameterValue","parameterPathString","url","pathToAppend","parsedUrl","newPath","searchStart","search","queryParameter","queryParameterValue","delimiter","simpleParseQueryParams","queryString","pairs","pair","existingValue","noOverwrite","combinedParams","valueSet","searchPieces","subValue","ServiceClient","createDefaultPipeline","policy","position","afterPhase","endpoint","requestOptions","rawResponse","flatResponse","credentialScopes","getCredentialScopes","credentialOptions","parseCAEChallenge","challenge","keyValue","a","authorizeRequestOnClaimChallenge","parsedChallenge","Constants","isUuid","authorizeRequestOnTenantChallenge","challengeOptions","requestToOptions","getChallenge","challengeInfo","parseChallenge","challengeScopes","buildScopes","extractTenantId","DefaultScopeSuffix","serviceFabricErrorMessage","mapScopesToResource","parseExpirationTimestamp","asNumber","asDate","parseRefreshTimestamp","noCorrelationId","getIdentityClientAuthorityHost","packageDetails","userAgentPrefix","refreshToken","clientSecret","refreshParams","query","urlSuffix","correlationId","controllers","existingOnAbort","unavailableUpn","base64Metadata","appid","upn","tid","oid","Buffer","ClientSecretCredential","newOptions","tokenResponse","EnvironmentCredential","ClientCertificateCredential","ClientAssertionCredential","AzureCliCredential","AzureDeveloperCliCredential","ensureValidScopeForDevTimeCreds","getScopeResource","isLocationDefined","generateMsalBrowserConfiguration","authority","redirectHash","loginStyle","additionallyAllowedTenantIds","msalConfig","disableAutomaticAuthentication","loginHint","app","getApp","handleBrowserResult","msalApp","activeAccount","allAccounts","msalAccount","handleResult","handleRedirect","getActiveAccount","login","loginRequest","getTokenSilent","parameters","getTokenInteractive","getToken","getTokenTenantId","InteractiveBrowserCredential","browserOptions","loginStyles","msalOptions","arrayScopes","ManagedIdentityCredential","DeviceCodeCredential","AzurePipelinesCredential","AuthorizationCodeCredential","AzurePowerShellCredential","UsernamePasswordCredential","tenantIdOrName","username","password","webResource","vsCodeCredentialControl","_finder","VisualStudioCodeCredential","OnBehalfOfCredential","WorkloadIdentityCredential","getBearerTokenProvider","tracingOptions","getRefreshedToken","getDefaultAzureCredential"],"sourceRoot":""}